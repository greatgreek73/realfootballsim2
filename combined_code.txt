
# --- ?????? ????? C:\realfootballsim\accounts\migrations\0001_initial.py ---

# Generated by Django 5.0.1 on 2024-12-07 04:02

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='CustomUser',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]

# --- ????? ????? C:\realfootballsim\accounts\migrations\0001_initial.py ---


# --- ?????? ????? C:\realfootballsim\accounts\migrations\__init__.py ---


# --- ????? ????? C:\realfootballsim\accounts\migrations\__init__.py ---


# --- ?????? ????? C:\realfootballsim\accounts\templates\accounts\login.html ---

{% extends 'core/base.html' %}

{% block title %}Login{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h3 class="mb-0">Login</h3>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% for field in form %}
                            <div class="form-group mb-3">
                                <label for="{{ field.id_for_label }}">{{ field.label }}</label>
                                {{ field }}
                                {% if field.errors %}
                                    {% for error in field.errors %}
                                        <div class="alert alert-danger mt-1">
                                            {{ error }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        {% endfor %}
                        <button type="submit" class="btn btn-primary">Login</button>
                    </form>
                </div>
                <div class="card-footer">
                    <p class="mb-0">Don't have an account? <a href="{% url 'accounts:register' %}">Register here</a></p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\accounts\templates\accounts\login.html ---


# --- ?????? ????? C:\realfootballsim\accounts\templates\accounts\logout.html ---

{% extends 'core/base.html' %}

{% block title %}Logged Out{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h3 class="mb-0">Logged Out</h3>
                </div>
                <div class="card-body">
                    <p>You have been successfully logged out.</p>
                    <a href="{% url 'accounts:login' %}" class="btn btn-primary">Login Again</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\accounts\templates\accounts\logout.html ---


# --- ?????? ????? C:\realfootballsim\accounts\templates\accounts\register.html ---

{% extends 'core/base.html' %}

{% block title %}Register{% endblock %}

{% block content %}
<div class="container">
    <div class="row justify-content-center mt-5">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header">
                    <h3 class="mb-0">Register</h3>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% for field in form %}
                            <div class="form-group mb-3">
                                <label for="{{ field.id_for_label }}">{{ field.label }}</label>
                                {{ field }}
                                {% if field.errors %}
                                    {% for error in field.errors %}
                                        <div class="alert alert-danger mt-1">
                                            {{ error }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        {% endfor %}
                        <button type="submit" class="btn btn-primary">Register</button>
                    </form>
                </div>
                <div class="card-footer">
                    <p class="mb-0">Already have an account? <a href="{% url 'accounts:login' %}">Login here</a></p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\accounts\templates\accounts\register.html ---


# --- ?????? ????? C:\realfootballsim\accounts\admin.py ---

from django.contrib import admin
from .models import CustomUser

class CustomUserAdmin(admin.ModelAdmin):
    list_display = ('username', 'email', 'is_staff', 'last_login')  # Добавление 'email' в список
    search_fields = ('username', 'email')  # Убедитесь, что поиск по email также включен

admin.site.register(CustomUser, CustomUserAdmin)

# --- ????? ????? C:\realfootballsim\accounts\admin.py ---


# --- ?????? ????? C:\realfootballsim\accounts\apps.py ---

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

# --- ????? ????? C:\realfootballsim\accounts\apps.py ---


# --- ?????? ????? C:\realfootballsim\accounts\forms.py ---

from django import forms
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth import get_user_model

User = get_user_model()

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField(
        widget=forms.EmailInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your email'
        })
    )
    username = forms.CharField(
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Choose a username'
        })
    )
    password1 = forms.CharField(
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your password'
        })
    )
    password2 = forms.CharField(
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirm your password'
        })
    )

    class Meta:
        model = User
        fields = ("username", "email", "password1", "password2")

class CustomAuthenticationForm(AuthenticationForm):
    username = forms.CharField(
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your username'
        })
    )
    password = forms.CharField(
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter your password'
        })
    )

    class Meta:
        model = User
        fields = ("username", "password")

# --- ????? ????? C:\realfootballsim\accounts\forms.py ---


# --- ?????? ????? C:\realfootballsim\accounts\models.py ---

from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    email = models.EmailField(unique=True, blank=False)

# --- ????? ????? C:\realfootballsim\accounts\models.py ---


# --- ?????? ????? C:\realfootballsim\accounts\tests.py ---

from django.test import TestCase
from django.contrib.auth import get_user_model
from django.urls import reverse

class AuthenticationTestCase(TestCase):
    def setUp(self):
        # Создание пользователя для тестирования
        self.user = get_user_model().objects.create_user(username='testuser', password='12345')

    def test_successful_login(self):
        # Отправка данных аутентификации на проверку
        response = self.client.post(reverse('login'), {'username': 'testuser', 'password': '12345'})
        # Проверка успешного входа
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Вы успешно вошли в систему')

# --- ????? ????? C:\realfootballsim\accounts\tests.py ---


# --- ?????? ????? C:\realfootballsim\accounts\urls.py ---

from django.urls import path
from .views import RegisterView, LoginView, LogoutView

app_name = 'accounts'

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('login/', LoginView.as_view(), name='login'),
    path('logout/', LogoutView.as_view(), name='logout'),
]

# --- ????? ????? C:\realfootballsim\accounts\urls.py ---


# --- ?????? ????? C:\realfootballsim\accounts\views.py ---

from django.contrib.auth import logout
from django.shortcuts import redirect
from django.urls import reverse_lazy
from django.views.generic import FormView
from django.contrib.auth.views import LogoutView as BaseLogoutView
from .forms import CustomUserCreationForm, CustomAuthenticationForm
from django.contrib.auth import login, logout

class RegisterView(FormView):
    template_name = 'accounts/register.html'
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('accounts:login')

    def form_valid(self, form):
        user = form.save()
        if hasattr(user, 'club'):
            return redirect('clubs:club_detail', user.club.pk)
        else:
            return redirect('clubs:create_club')

class LoginView(FormView):
    template_name = 'accounts/login.html'
    form_class = CustomAuthenticationForm
    
    def form_valid(self, form):
        user = form.get_user()
        login(self.request, user)
        
        if hasattr(user, 'club'):
            return redirect('clubs:club_detail', user.club.pk)
        return redirect('clubs:create_club')

class LogoutView(BaseLogoutView):
    next_page = reverse_lazy('accounts:login')
    
    def get(self, request, *args, **kwargs):
        return self.post(request, *args, **kwargs)
    
    def post(self, request, *args, **kwargs):
        logout(request)
        return redirect(self.next_page)

# --- ????? ????? C:\realfootballsim\accounts\views.py ---


# --- ?????? ????? C:\realfootballsim\accounts\__init__.py ---


# --- ????? ????? C:\realfootballsim\accounts\__init__.py ---


# --- ?????? ????? C:\realfootballsim\clubs\management\commands\assign_leagues.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from clubs.models import Club
from tournaments.models import League
from django.db.models import Count

class Command(BaseCommand):
    help = 'Assigns clubs to leagues ensuring 16 teams per league'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Сначала очистим существующие привязки к лигам только для ботов
                Club.objects.filter(is_bot=True).update(league=None)

                # Получаем все лиги, сортируем по стране и уровню
                leagues = League.objects.all().order_by('country', 'level')
                
                # Для каждой страны отдельно обрабатываем клубы
                for league in leagues:
                    existing_clubs = Club.objects.filter(league=league).count()
                    if existing_clubs > 0:
                        self.stdout.write(f"League {league} already has {existing_clubs} clubs")
                        continue

                    # Берем только бот-клубы без лиги из той же страны
                    available_clubs = Club.objects.filter(
                        country=league.country,
                        league__isnull=True,
                        is_bot=True  # Только боты
                    )[:16]  # Берем только 16 клубов
                    
                    if available_clubs.count() < 16:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Not enough bot clubs for {league}. Found only {available_clubs.count()}"
                            )
                        )
                        continue

                    # Назначаем лигу для клубов
                    for club in available_clubs:
                        club.league = league
                        club.save()
                        
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Assigned {available_clubs.count()} bot clubs to {league}"
                        )
                    )

                # Проверяем результаты
                for league in leagues:
                    bot_count = Club.objects.filter(league=league, is_bot=True).count()
                    human_count = Club.objects.filter(league=league, is_bot=False).count()
                    self.stdout.write(f"{league}: {bot_count} bot teams, {human_count} human teams")

        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error occurred: {str(e)}"))
            raise e

# --- ????? ????? C:\realfootballsim\clubs\management\commands\assign_leagues.py ---


# --- ?????? ????? C:\realfootballsim\clubs\management\commands\check_leagues.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from clubs.models import Club
from tournaments.models import League
from django.db.models import Count

class Command(BaseCommand):
    help = 'Checks current distribution of clubs in leagues'

    def handle(self, *args, **options):
        # Считаем команды без лиги
        unassigned_clubs = Club.objects.filter(league__isnull=True).count()
        self.stdout.write(f"\nКоманды без лиги: {unassigned_clubs}")

        # Группируем по странам
        countries = set(Club.objects.values_list('country', flat=True))
        
        self.stdout.write("\nРаспределение по странам:")
        for country in sorted(countries):
            clubs = Club.objects.filter(country=country)
            leagues = League.objects.filter(country=country).order_by('level')
            
            self.stdout.write(f"\n{country}:")
            self.stdout.write(f"Всего команд: {clubs.count()}")
            self.stdout.write(f"Количество лиг: {leagues.count()}")
            
            if leagues.exists():
                self.stdout.write("Распределение по лигам:")
                for league in leagues:
                    club_count = Club.objects.filter(league=league).count()
                    self.stdout.write(f"  {league.name} (уровень {league.level}): {club_count} команд")
            
            unassigned = clubs.filter(league__isnull=True).count()
            if unassigned > 0:
                self.stdout.write(f"Не распределено: {unassigned} команд")

# --- ????? ????? C:\realfootballsim\clubs\management\commands\check_leagues.py ---


# --- ?????? ????? C:\realfootballsim\clubs\management\commands\generate_players.py ---

from django.core.management.base import BaseCommand
from clubs.models import Club
from players.models import Player
from django.db import transaction
from faker import Faker
from players.utils import generate_player_stats
from clubs.views import get_locale_from_country_code
from tqdm import tqdm
import random

class Command(BaseCommand):
    help = 'Generates 5 random players for each club'

    def handle(self, *args, **options):
        clubs = Club.objects.all()
        total_clubs = clubs.count()
        
        self.stdout.write(f"Found {total_clubs} clubs. Starting player generation...")
        
        positions = [
            "Goalkeeper",
            "Right Back",
            "Center Back",
            "Left Back",
            "Defensive Midfielder",
            "Central Midfielder",
            "Attacking Midfielder",
            "Right Midfielder",
            "Left Midfielder",
            "Center Forward"
        ]

        with transaction.atomic():
            for club in tqdm(clubs, desc="Generating players"):
                # Создаем Faker с локалью, соответствующей стране клуба
                locale = get_locale_from_country_code(club.country.code)
                fake = Faker(locale)

                # Обязательно создаем вратаря
                self.create_player_for_club(
                    club=club,
                    fake=fake,
                    position="Goalkeeper",
                    player_class=random.randint(1, 4)
                )
                
                # Создаем еще 4 случайных полевых игрока
                for _ in range(4):
                    # Исключаем вратаря из случайного выбора позиций
                    position = random.choice([pos for pos in positions if pos != "Goalkeeper"])
                    self.create_player_for_club(
                        club=club,
                        fake=fake,
                        position=position,
                        player_class=random.randint(1, 4)
                    )
        
        self.stdout.write(self.style.SUCCESS(
            f'Successfully generated {total_clubs * 5} players for {total_clubs} clubs'
        ))

    def create_player_for_club(self, club, fake, position, player_class):
        """Создает одного игрока для клуба"""
        # Генерируем уникальное имя
        while True:
            first_name = fake.first_name_male()
            last_name = fake.last_name_male() if hasattr(fake, 'last_name_male') else fake.last_name()
            if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
                break

        # Генерируем характеристики в зависимости от позиции
        stats = generate_player_stats(position, player_class)

        if position == 'Goalkeeper':
            player = Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=17,
                position=position,
                player_class=player_class,
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                positioning=stats['positioning'],
                reflexes=stats['reflexes'],
                handling=stats['handling'],
                aerial=stats['aerial'],
                jumping=stats['jumping'],
                command=stats['command'],
                throwing=stats['throwing'],
                kicking=stats['kicking']
            )
        else:
            player = Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=17,
                position=position,
                player_class=player_class,
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                marking=stats['marking'],
                tackling=stats['tackling'],
                work_rate=stats['work_rate'],
                positioning=stats['positioning'],
                passing=stats['passing'],
                crossing=stats['crossing'],
                dribbling=stats['dribbling'],
                ball_control=stats['ball_control'],
                heading=stats['heading'],
                finishing=stats['finishing'],
                long_range=stats['long_range'],
                vision=stats['vision']
            )

        return player

# --- ????? ????? C:\realfootballsim\clubs\management\commands\generate_players.py ---


# --- ?????? ????? C:\realfootballsim\clubs\management\commands\__init__.py ---


# --- ????? ????? C:\realfootballsim\clubs\management\commands\__init__.py ---


# --- ?????? ????? C:\realfootballsim\clubs\management\__init__.py ---


# --- ????? ????? C:\realfootballsim\clubs\management\__init__.py ---


# --- ?????? ????? C:\realfootballsim\clubs\migrations\0001_initial.py ---

# Generated by Django 5.0.1 on 2024-12-07 04:02

import django_countries.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Club',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, verbose_name='Club Name')),
                ('country', django_countries.fields.CountryField(max_length=2, verbose_name='Country')),
                ('lineup', models.JSONField(blank=True, null=True)),
                ('is_bot', models.BooleanField(default=False, help_text='Indicates if this team is controlled by AI', verbose_name='Bot Team')),
                ('promoted', models.BooleanField(default=False, help_text='Команда повышена в классе')),
                ('relegated', models.BooleanField(default=False, help_text='Команда понижена в классе')),
            ],
        ),
    ]

# --- ????? ????? C:\realfootballsim\clubs\migrations\0001_initial.py ---


# --- ?????? ????? C:\realfootballsim\clubs\migrations\0002_initial.py ---

# Generated by Django 5.0.1 on 2024-12-07 04:02

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('clubs', '0001_initial'),
        ('tournaments', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='club',
            name='league',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='clubs', to='tournaments.league'),
        ),
        migrations.AddField(
            model_name='club',
            name='owner',
            field=models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='club', to=settings.AUTH_USER_MODEL, verbose_name='Owner'),
        ),
    ]

# --- ????? ????? C:\realfootballsim\clubs\migrations\0002_initial.py ---


# --- ?????? ????? C:\realfootballsim\clubs\migrations\__init__.py ---


# --- ????? ????? C:\realfootballsim\clubs\migrations\__init__.py ---


# --- ?????? ????? C:\realfootballsim\clubs\templates\clubs\club_detail.html ---

{% extends 'core/base.html' %}

{% block title %}{{ club.name }}{% endblock %}

{% block content %}
<div class="container">
    <!-- Club Header Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <h1>
                        {{ club.name }}
                        {% if club.is_bot %}
                            <span class="badge bg-secondary">BOT</span>
                        {% endif %}
                    </h1>
                    <div class="club-info">
                        <p class="mb-1">
                            <strong>Country:</strong> {{ club.country }}
                        </p>
                        <p class="mb-1">
                            <strong>League:</strong> {{ club.league.name }} (Division {{ club.league.level }})
                        </p>
                        <p class="mb-1">
                            <strong>Status:</strong>
                            {% if club.is_bot %}
                                <span class="text-muted">AI Controlled</span>
                            {% else %}
                                Owned by {{ club.owner.username }}
                            {% endif %}
                        </p>
                    </div>
                </div>
                {% if user == club.owner %}
                <div>
                    <a href="{% url 'clubs:team_selection' club.id %}" class="btn btn-primary">
                        Select Team Lineup
                    </a>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Players Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title h4 mb-0">Players</h2>
                </div>
                <div class="card-body">
                    {% if user == club.owner %}
                    <div class="row mb-3">
                        <div class="col-12">
                            <form method="get" action="{% url 'clubs:create_player' club.id %}" class="row g-3">
                                <div class="col-md-4">
                                    <label for="position" class="form-label">Choose Position:</label>
                                    <select class="form-select" id="position" name="position" required>
                                        <option value="">Select a position</option>
                                        <option value="Goalkeeper">Goalkeeper</option>
                                        <option value="Right Back">Right Back</option>
                                        <option value="Left Back">Left Back</option>
                                        <option value="Center Back">Center Back</option>
                                        <option value="Defensive Midfielder">Defensive Midfielder</option>
                                        <option value="Right Midfielder">Right Midfielder</option>
                                        <option value="Central Midfielder">Central Midfielder</option>
                                        <option value="Left Midfielder">Left Midfielder</option>
                                        <option value="Attacking Midfielder">Attacking Midfielder</option>
                                        <option value="Center Forward">Center Forward</option>
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label for="player_class" class="form-label">Choose Player Class:</label>
                                    <select class="form-select" id="player_class" name="player_class" required>
                                        <option value="">Select a class</option>
                                        <option value="1">Class 1</option>
                                        <option value="2">Class 2</option>
                                        <option value="3">Class 3</option>
                                        <option value="4">Class 4</option>
                                    </select>
                                </div>
                                <div class="col-md-4 d-flex align-items-end gap-2">
                                    <button type="submit" class="btn btn-primary">Create Player</button>
                                    <a href="{% url 'matches:simulate_match' 0 %}" class="btn btn-primary" target="_blank">Create New Match</a>
                                </div>
                            </form>
                        </div>
                    </div>
                    {% endif %}
                    
                    <div class="table-responsive">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Position</th>
                                    <th>Class</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for player in players %}
                                <tr>
                                    <td>{{ player.first_name }} {{ player.last_name }}</td>
                                    <td>
                                        <span class="badge bg-primary">{{ player.position }}</span>
                                    </td>
                                    <td>
                                        {% if player.player_class %}
                                            <span class="badge bg-info">Class {{ player.player_class }}</span>
                                        {% endif %}
                                    </td>
                                    <td>
                                        <a href="{% url 'players:player_detail' player.pk %}" 
                                           class="btn btn-sm btn-outline-primary">
                                            View Details
                                        </a>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="4" class="text-center">No players found</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\clubs\templates\clubs\club_detail.html ---


# --- ?????? ????? C:\realfootballsim\clubs\templates\clubs\create_club.html ---

{% extends 'core/base.html' %}
{% block title %}Create Club{% endblock %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-md-6 offset-md-3">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title mb-0">Create New Club</h3>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% for field in form %}
                            <div class="form-group mb-3">
                                <label for="{{ field.id_for_label }}" class="form-label">{{ field.label }}</label>
                                {{ field }}
                                {% if field.help_text %}
                                    <small class="form-text text-muted">{{ field.help_text }}</small>
                                {% endif %}
                                {% if field.errors %}
                                    {% for error in field.errors %}
                                        <div class="alert alert-danger mt-1">
                                            {{ error }}
                                        </div>
                                    {% endfor %}
                                {% endif %}
                            </div>
                        {% endfor %}
                        {% if form.non_field_errors %}
                            {% for error in form.non_field_errors %}
                                <div class="alert alert-danger">
                                    {{ error }}
                                </div>
                            {% endfor %}
                        {% endif %}
                        <div class="d-grid">
                            <button type="submit" class="btn btn-primary">Create Club</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\clubs\templates\clubs\create_club.html ---


# --- ?????? ????? C:\realfootballsim\clubs\templates\clubs\team_selection.html ---

{% extends 'core/base.html' %}
{% load static %}

{% block title %}Team Selection - {{ club.name }}{% endblock %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h2 class="mb-0">Team Selection</h2>
                        <a href="{% url 'clubs:club_detail' club.id %}" class="btn btn-outline-secondary">
                            Back to Club
                        </a>
                    </div>
                </div>
                <div class="card-body">

                    <!-- Добавляем секцию для выбора тактики -->
                    <div class="tactics-section">
                        <label for="tacticSelect"><strong>Select Tactic:</strong></label>
                        <select id="tacticSelect">
                            <option value="attacking">Attacking</option>
                            <option value="balanced" selected>Balanced</option>
                            <option value="defensive">Defensive</option>
                        </select>
                    </div>
                    <!-- Конец секции выбора тактики -->

                    <div class="pitch" id="pitch">
                        <!-- Player slots will be added here dynamically -->
                    </div>

                    <div class="text-center mt-4">
                        <button id="resetButton" class="btn btn-warning">Reset Lineup</button>
                        <div id="saveStatus" class="mt-2"></div>
                    </div>

                    <div class="mt-4">
                        <h3 class="h4 mb-3">Available Players</h3>
                        <div class="player-list" id="playerList">
                            <!-- Available players will be added here dynamically -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Добавляем скрытое поле с ID клуба -->
<input type="hidden" id="clubId" value="{{ club.id }}">

<style>
    .pitch {
        width: 100%;
        max-width: 800px;
        height: 600px;
        background-color: #4CAF50;
        background-image: 
            linear-gradient(#ffffff 1px, transparent 1px),
            linear-gradient(90deg, #ffffff 1px, transparent 1px);
        background-size: 50px 50px;
        position: relative;
        margin: 0 auto;
        border: 2px solid #388E3C;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .player-slot {
        width: 70px;
        height: 70px;
        background-color: rgba(255, 255, 255, 0.8);
        border: 2px solid #fff;
        border-radius: 50%;
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        transition: all 0.2s ease;
        transform: translate(-50%, -50%);
    }

    .player-slot:hover {
        background-color: rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }

    .player-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        min-height: 100px;
    }

    .player-item {
        width: 130px;
        height: 70px;
        background-color: #fff;
        padding: 8px;
        cursor: move;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        text-align: center;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s ease;
        margin: 0;
    }

    .player-item:hover {
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }

    .player-item.goalkeeper {
        background-color: #fff3cd;
        border-left: 4px solid #ffc107;
    }

    .player-item.defender {
        background-color: #cfe2ff;
        border-left: 4px solid #0d6efd;
    }

    .player-item.midfielder {
        background-color: #d1e7dd;
        border-left: 4px solid #198754;
    }

    .player-item.forward {
        background-color: #f8d7da;
        border-left: 4px solid #dc3545;
    }

    .player-name {
        font-weight: bold;
        margin-bottom: 4px;
    }

    .player-position {
        font-size: 11px;
        color: #6c757d;
    }

    .position-label {
        position: absolute;
        bottom: -20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        color: white;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        font-weight: bold;
        background-color: rgba(0,0,0,0.3);
        padding: 2px 6px;
        border-radius: 3px;
    }

    .sortable-ghost {
        opacity: 0.4;
    }

    .sortable-chosen {
        opacity: 0.8;
        transform: scale(1.05);
    }

    .sortable-drag {
        opacity: 0.8;
    }

    #saveStatus {
        min-height: 24px;
        transition: all 0.3s ease;
    }

    #saveStatus.alert {
        display: inline-block;
        padding: 0.5rem 1rem;
        margin: 0;
        font-size: 14px;
    }

    .pitch::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 2px;
        background-color: rgba(255, 255, 255, 0.5);
    }

    .pitch::after {
        content: '';
        position: absolute;
        top: 25%;
        bottom: 25%;
        left: 50%;
        width: 2px;
        background-color: rgba(255, 255, 255, 0.5);
        transform: translateX(-50%);
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
<script src="{% static 'js/team_selection.js' %}"></script>
{% endblock %}

# --- ????? ????? C:\realfootballsim\clubs\templates\clubs\team_selection.html ---


# --- ?????? ????? C:\realfootballsim\clubs\admin.py ---

from django.contrib import admin
from .models import Club

@admin.register(Club)
class ClubAdmin(admin.ModelAdmin):
    list_display = ['name', 'country', 'owner', 'is_bot']  # явно перечисляем все поля
    list_filter = ['country', 'is_bot']
    search_fields = ['name', 'owner__username']

# --- ????? ????? C:\realfootballsim\clubs\admin.py ---


# --- ?????? ????? C:\realfootballsim\clubs\apps.py ---

from django.apps import AppConfig


class ClubsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'clubs'

# --- ????? ????? C:\realfootballsim\clubs\apps.py ---


# --- ?????? ????? C:\realfootballsim\clubs\country_locales.py ---

# country_locales.py

country_locales = {
    'US': 'en_US',
    'FR': 'fr_FR',
    'DE': 'de_DE',
    'ES': 'es_ES',
    'IT': 'it_IT',
    'RU': 'ru_RU',
    # Добавьте другие сопоставления по мере необходимости
}

# --- ????? ????? C:\realfootballsim\clubs\country_locales.py ---


# --- ?????? ????? C:\realfootballsim\clubs\forms.py ---

from django import forms
from django_countries.widgets import CountrySelectWidget
from .models import Club

class ClubForm(forms.ModelForm):
    class Meta:
        model = Club
        fields = ['name', 'country']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter club name'
            }),
            'country': CountrySelectWidget(attrs={
                'class': 'form-control'
            })
        }

    def clean(self):
        cleaned_data = super().clean()
        self.instance._skip_clean = True
        return cleaned_data

    def save(self, commit=True, user=None):
        instance = super().save(commit=False)
        
        if user:
            instance.owner = user
            instance.is_bot = False
        
        if commit and not hasattr(instance, '_skip_save'):
            instance._skip_save = True
            instance.save()
        
        return instance
    



# --- ????? ????? C:\realfootballsim\clubs\forms.py ---


# --- ?????? ????? C:\realfootballsim\clubs\models.py ---

from django.db import models
from django.conf import settings
from django_countries.fields import CountryField
from django.core.exceptions import ValidationError

class Club(models.Model):
    name = models.CharField(max_length=100, verbose_name="Club Name")
    country = CountryField(blank_label='(select country)', verbose_name="Country")
    owner = models.OneToOneField(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE, 
        verbose_name="Owner", 
        related_name="club",
        null=True,
        blank=True
    )
    league = models.ForeignKey(
        'tournaments.League',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='clubs'
    )
    lineup = models.JSONField(null=True, blank=True)
    is_bot = models.BooleanField(
        default=False,
        verbose_name="Bot Team",
        help_text="Indicates if this team is controlled by AI"
    )
    promoted = models.BooleanField(
        default=False,
        help_text="Команда повышена в классе"
    )
    relegated = models.BooleanField(
        default=False,
        help_text="Команда понижена в классе"
    )

    def __str__(self):
        return self.name

    def clean(self):
        if hasattr(self, '_skip_clean'):
            return
            
        if not self.is_bot and not self.owner:
            raise ValidationError("Non-bot teams must have an owner")

    def save(self, *args, **kwargs):
        if not hasattr(self, '_skip_clean'):
            self.full_clean()
        super().save(*args, **kwargs)

# --- ????? ????? C:\realfootballsim\clubs\models.py ---


# --- ?????? ????? C:\realfootballsim\clubs\tests.py ---

from django.test import TestCase

# Create your tests here.

# --- ????? ????? C:\realfootballsim\clubs\tests.py ---


# --- ?????? ????? C:\realfootballsim\clubs\urls.py ---

from django.urls import path
from . import views

app_name = 'clubs'

urlpatterns = [
    path('create/', views.CreateClubView.as_view(), name='create_club'),
    path('detail/<int:pk>/', views.ClubDetailView.as_view(), name='club_detail'),
    path('detail/<int:pk>/create_player/', views.create_player, name='create_player'),
    path('detail/<int:pk>/team-selection/', views.team_selection_view, name='team_selection'),
    path('detail/<int:pk>/get-players/', views.get_players, name='get_players'),
    path('detail/<int:pk>/save-team-lineup/', views.save_team_lineup, name='save_team_lineup'),
    path('detail/<int:pk>/get-team-lineup/', views.get_team_lineup, name='get_team_lineup'),
    
]

# --- ????? ????? C:\realfootballsim\clubs\urls.py ---


# --- ?????? ????? C:\realfootballsim\clubs\views.py ---

from django.shortcuts import redirect, render, get_object_or_404
from django.views.generic import CreateView, DetailView
from django.contrib import messages
from django.http import JsonResponse, HttpResponse
from django.views.decorators.http import require_http_methods
from django.db import transaction
from faker import Faker
from .models import Club
from players.models import Player
from tournaments.models import Championship, League
from players.utils import generate_player_stats
from .country_locales import country_locales
from .forms import ClubForm
import json
import random
import logging

logger = logging.getLogger(__name__)

class CreateClubView(CreateView):
    model = Club
    form_class = ClubForm
    template_name = 'clubs/create_club.html'

    def form_valid(self, form):
        try:
            with transaction.atomic():
                # 1. Получаем данные из формы без сохранения
                club = form.save(commit=False)
                
                # 2. Установить владельца и другие поля
                club.owner = self.request.user
                club.is_bot = False
                club._skip_clean = True
                
                # 3. Найти подходящую лигу
                league = League.objects.filter(
                    country=club.country,
                    level=1
                ).first()
                
                if not league:
                    messages.error(
                        self.request,
                        f'Не найдена лига для страны {club.country.name}'
                    )
                    return self.form_invalid(form)

                club.league = league
                
                # 4. Сохраняем клуб
                club.save()

                # 5. Проверяем ID сразу после сохранения
                if not club.id:
                    messages.error(self.request, "Ошибка при создании клуба: не получен ID")
                    return self.form_invalid(form)

                messages.info(self.request, f"Клуб создан с ID: {club.id}")
                
                # 6. Подождать немного, чтобы сигнал успел обработаться
                from time import sleep
                sleep(0.2)
                
                # 7. Проверить добавление в чемпионат
                championship = Championship.objects.filter(
                    teams=club,
                    season__is_active=True
                ).first()
                
                if championship:
                    messages.success(
                        self.request,
                        f'Клуб "{club.name}" успешно создан и добавлен в {championship.league.name}!'
                    )
                else:
                    # Проверяем причину отсутствия в чемпионате
                    active_season = Championship.objects.filter(
                        season__is_active=True
                    ).exists()
                    if not active_season:
                        messages.warning(
                            self.request,
                            'Нет активного сезона в системе.'
                        )
                    else:
                        messages.warning(
                            self.request,
                            f'Клуб "{club.name}" создан, но не добавлен в чемпионат. '
                            'Возможно, нет свободных мест.'
                        )

                # 8. Перенаправляем на страницу клуба
                return redirect('clubs:club_detail', pk=club.id)
                    
        except Exception as e:
            logger.error(f'Error creating club: {str(e)}')
            messages.error(self.request, f'Ошибка при создании клуба: {str(e)}')
            return self.form_invalid(form)

    def form_invalid(self, form):
        messages.error(
            self.request, 
            'Ошибка при создании клуба. Проверьте введенные данные.'
        )
        return super().form_invalid(form)

class ClubDetailView(DetailView):
    model = Club
    template_name = 'clubs/club_detail.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['players'] = Player.objects.filter(club=self.object)
        
        championship = Championship.objects.filter(
            teams=self.object,
            season__is_active=True
        ).first()
        context['championship'] = championship
        
        return context

def get_locale_from_country_code(country_code):
    """Возвращает локаль для заданного кода страны"""
    return country_locales.get(country_code, 'en_US')

@require_http_methods(["GET"])
def create_player(request, pk):
    """Создает нового игрока для клуба"""
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return HttpResponse("У вас нет прав для создания игроков в этом клубе.", status=403)
    
    position = request.GET.get('position')
    player_class = int(request.GET.get('player_class', 1))
    
    if not position:
        return HttpResponse("Пожалуйста, выберите позицию.")

    country_code = club.country.code
    locale = get_locale_from_country_code(country_code)
    fake = Faker(locale)

    attempts = 0
    max_attempts = 100
    while attempts < max_attempts:
        first_name = fake.first_name_male()
        last_name = fake.last_name_male() if hasattr(fake, 'last_name_male') else fake.last_name()
        if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
            break
        attempts += 1
    
    if attempts >= max_attempts:
        messages.error(request, f'Не удалось создать уникальное имя для игрока')
        return redirect('clubs:club_detail', pk=pk)

    try:
        stats = generate_player_stats(position, player_class)
        
        player = Player.objects.create(
            club=club,
            first_name=first_name,
            last_name=last_name,
            nationality=club.country,
            age=random.randint(17, 35),
            position=position,
            player_class=player_class,
            **stats
        )

        messages.success(
            request, 
            f'Игрок {player.first_name} {player.last_name} успешно создан!'
        )
    except Exception as e:
        messages.error(
            request,
            f'Ошибка при создании игрока: {str(e)}'
        )
        logger.error(f'Error creating player: {str(e)}')

    return redirect('clubs:club_detail', pk=pk)

@require_http_methods(["GET"])
def team_selection_view(request, pk):
    """Отображение страницы выбора состава"""
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        messages.error(request, "У вас нет прав для просмотра этой страницы.")
        return redirect('clubs:club_detail', pk=pk)
    
    context = {
        'club': club,
        'current_section': 'team_selection'
    }
    # Рендерим шаблон командного выбора, где уже есть select для тактики
    return render(request, 'clubs/team_selection.html', context)

@require_http_methods(["GET"])
def get_players(request, pk):
    """Получение списка игроков клуба"""
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return JsonResponse({"error": "Доступ запрещен"}, status=403)
    
    players = Player.objects.filter(club=club)
    player_data = [{
        'id': player.id,
        'name': f"{player.first_name} {player.last_name}",
        'position': player.position,
        'playerClass': player.player_class,
        'attributes': {
            'stamina': player.stamina,
            'strength': player.strength,
            'speed': player.pace
        }
    } for player in players]
    return JsonResponse(player_data, safe=False)

@require_http_methods(["POST"])
def save_team_lineup(request, pk):
    """Сохранение состава команды и тактики"""
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return JsonResponse({"error": "Доступ запрещен"}, status=403)
    
    try:
        data = json.loads(request.body)
        lineup = data.get('lineup', {})
        tactic = data.get('tactic', 'balanced')  # По умолчанию сбалансированная тактика

        if len(lineup) > 11:
            return JsonResponse({
                "success": False,
                "error": "В составе не может быть больше 11 игроков"
            })

        # Проверка наличия вратаря
        goalkeeper_positions = [
            pos for pos, player_id in lineup.items() 
            if Player.objects.get(id=player_id).position == 'Goalkeeper'
        ]
        if not goalkeeper_positions:
            return JsonResponse({
                "success": False,
                "error": "В составе должен быть вратарь"
            })

        # Сохраняем состав и тактику в клуб
        # Представим, что club.lineup - JSONField или TextField, где мы можем хранить словарь
        club.lineup = {
            'lineup': lineup,
            'tactic': tactic
        }
        club.save()
        
        return JsonResponse({
            "success": True,
            "message": "Состав и тактика успешно сохранены"
        })
        
    except json.JSONDecodeError:
        return JsonResponse({
            "success": False,
            "error": "Некорректный формат данных"
        }, status=400)
    except Exception as e:
        logger.error(f'Error saving team lineup: {str(e)}')
        return JsonResponse({
            "success": False,
            "error": str(e)
        }, status=500)

@require_http_methods(["GET"])
def get_team_lineup(request, pk):
    """Получение текущего состава команды и тактики"""
    club = get_object_or_404(Club, pk=pk)
    if club.owner != request.user:
        return JsonResponse({"error": "Доступ запрещен"}, status=403)
    
    data = club.lineup or {}
    lineup = data.get('lineup', {})
    tactic = data.get('tactic', 'balanced')

    lineup_data = {
        'lineup': lineup,
        'tactic': tactic,
        'players': {}
    }
    
    if lineup:
        players = Player.objects.filter(id__in=lineup.values())
        lineup_data['players'] = {
            str(player.id): {
                'name': f"{player.first_name} {player.last_name}",
                'position': player.position,
                'playerClass': player.player_class
            } for player in players
        }
    
    return JsonResponse(lineup_data)

# --- ????? ????? C:\realfootballsim\clubs\views.py ---


# --- ?????? ????? C:\realfootballsim\clubs\__init__.py ---


# --- ????? ????? C:\realfootballsim\clubs\__init__.py ---


# --- ?????? ????? C:\realfootballsim\core\migrations\__init__.py ---


# --- ????? ????? C:\realfootballsim\core\migrations\__init__.py ---


# --- ?????? ????? C:\realfootballsim\core\templates\core\base.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Football Manager{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="{% url 'home' %}">Football Manager</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    {% if user.is_authenticated %}
                        <li class="nav-item">
                            {% if user.club and user.club.id %}
                                <a class="nav-link" href="{% url 'clubs:club_detail' user.club.id %}">My Club</a>
                            {% else %}
                                <a class="nav-link" href="{% url 'clubs:create_club' %}">Create Club</a>
                            {% endif %}
                        </li>
                        <li class="nav-item">
                            {% if user.club and user.club.id %}
                                <a class="nav-link" href="{% url 'tournaments:my_championship' %}">Tournaments</a>
                            {% else %}
                                <a class="nav-link" href="{% url 'tournaments:championship_list' %}">Tournaments</a>
                            {% endif %}
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'matches:match_list' %}">Matches</a>
                        </li>
                    {% endif %}
                </ul>
                <ul class="navbar-nav">
                    {% if user.is_authenticated %}
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'accounts:logout' %}">Logout</a>
                        </li>
                    {% else %}
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'accounts:login' %}">Login</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="{% url 'accounts:register' %}">Register</a>
                        </li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            {% endfor %}
        {% endif %}
        
        {% block content %}{% endblock %}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

# --- ????? ????? C:\realfootballsim\core\templates\core\base.html ---


# --- ?????? ????? C:\realfootballsim\core\templates\core\home.html ---

{% extends 'core/base.html' %}

{% block content %}
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-10">
            <div class="text-center mb-5">
                <h1 class="display-4">Welcome to Football Manager</h1>
                <p class="lead">Manage your team and compete in championships!</p>
            </div>

            {% if user.is_authenticated %}
                {% if user.club %}
                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title h5 mb-0">Your Club</h3>
                            </div>
                            <div class="card-body">
                                <h4 class="h5">{{ user.club.name }}</h4>
                                <p class="mb-2">
                                    <strong>League:</strong> {{ user.club.league.name }}
                                </p>
                                <a href="{% url 'clubs:club_detail' user.club.id %}" 
                                   class="btn btn-primary">View Club</a>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card">
                            <div class="card-header">
                                <h3 class="card-title h5 mb-0">Quick Actions</h3>
                            </div>
                            <div class="card-body">
                                <div class="d-grid gap-2">
                                    <a href="{% url 'tournaments:championship_detail' user.club.championship_set.first.id %}" 
                                       class="btn btn-outline-primary">View Championship</a>
                                    <a href="{% url 'clubs:team_selection' user.club.id %}" 
                                       class="btn btn-outline-primary">Select Team</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                {% else %}
                <div class="text-center mb-4">
                    <a href="{% url 'clubs:create_club' %}" class="btn btn-primary btn-lg">Create Your Club</a>
                </div>
                {% endif %}
            {% else %}
            <div class="row justify-content-center">
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-body text-center">
                            <h3 class="h4 mb-4">Get Started</h3>
                            <div class="d-grid gap-3">
                                <a href="{% url 'login' %}" class="btn btn-primary btn-lg">Login</a>
                                <a href="{% url 'register' %}" class="btn btn-outline-primary btn-lg">Register</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endif %}

            {% if championships %}
            <div class="mt-5">
                <h2 class="h3 mb-4">Active Championships</h2>
                <div class="row">
                    {% for championship in championships %}
                    <div class="col-md-4 mb-3">
                        <div class="card h-100">
                            <div class="card-body">
                                <h5 class="card-title">{{ championship.league.name }}</h5>
                                <p class="card-text">
                                    <small class="text-muted">
                                        {{ championship.league.country.name }} - 
                                        Division {{ championship.league.level }}
                                    </small>
                                </p>
                                <a href="{% url 'tournaments:championship_detail' championship.id %}" 
                                   class="btn btn-outline-primary btn-sm">View Details</a>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\core\templates\core\home.html ---


# --- ?????? ????? C:\realfootballsim\core\admin.py ---

from django.contrib import admin

# Register your models here.

# --- ????? ????? C:\realfootballsim\core\admin.py ---


# --- ?????? ????? C:\realfootballsim\core\apps.py ---

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

# --- ????? ????? C:\realfootballsim\core\apps.py ---


# --- ?????? ????? C:\realfootballsim\core\models.py ---

from django.db import models

# Create your models here.

# --- ????? ????? C:\realfootballsim\core\models.py ---


# --- ?????? ????? C:\realfootballsim\core\tests.py ---

from django.test import TestCase

# Create your tests here.

# --- ????? ????? C:\realfootballsim\core\tests.py ---


# --- ?????? ????? C:\realfootballsim\core\urls.py ---

from django.urls import path
from .views import home

urlpatterns = [
    path('', home, name='home'),
]

# --- ????? ????? C:\realfootballsim\core\urls.py ---


# --- ?????? ????? C:\realfootballsim\core\views.py ---

from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required

def home(request):
    if request.user.is_authenticated:
        if hasattr(request.user, 'club'):
            return redirect('clubs:club_detail', pk=request.user.club.id)
        return redirect('clubs:create_club')
    return redirect('accounts:login')  # Исправлено: добавлен namespace

# --- ????? ????? C:\realfootballsim\core\views.py ---


# --- ?????? ????? C:\realfootballsim\core\__init__.py ---


# --- ????? ????? C:\realfootballsim\core\__init__.py ---


# --- ?????? ????? C:\realfootballsim\matches\management\commands\test_match.py ---

from django.core.management.base import BaseCommand
from django.utils import timezone
from clubs.models import Club
from matches.models import Match
from matches.match_simulation import MatchSimulation
import random

class Command(BaseCommand):
    help = 'Tests match simulation with random teams'

    def handle(self, *args, **options):
        try:
            # Get random teams
            teams = list(Club.objects.all().order_by('?')[:2])
            if len(teams) < 2:
                self.stdout.write(self.style.ERROR('Not enough teams in database'))
                return

            home_team = teams[0]
            away_team = teams[1]

            # Display team information
            self.stdout.write('\nTeam Information:')
            self.stdout.write(f'\nHome team: {home_team.name}')
            self.stdout.write(f'Players: {home_team.player_set.count()}')
            
            self.stdout.write(f'\nAway team: {away_team.name}')
            self.stdout.write(f'Players: {away_team.player_set.count()}\n')

            # Create test match
            match = Match.objects.create(
                home_team=home_team,
                away_team=away_team,
                date=timezone.now(),
                status='scheduled'
            )

            # Initialize simulation
            simulation = MatchSimulation(match)
            
            # Simulate match
            self.stdout.write('\n=== MATCH START ===\n')
            
            for minute in range(90):
                if minute % 5 == 0:  # Show status every 5 minutes
                    self.stdout.write(f'\n=== MINUTE {minute} ===')
                    self.stdout.write(f'Score: {match.home_score} - {match.away_score}')
                    self.stdout.write(f'Possession: {simulation.match_stats["home"]["possession"]}% - {simulation.match_stats["away"]["possession"]}%')
                    self.stdout.write(f'Shots (on target): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]}) - {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
                
                simulation.simulate_minute(minute)
                
                # Show events immediately after they happen
                events = match.events.filter(minute=minute)
                for event in events:
                    self.stdout.write(f'{event.minute}\' - {event.description}')
            
            # Final statistics
            self.stdout.write('\n=== FINAL STATISTICS ===')
            self.stdout.write(f'\nFinal score: {match.home_score} - {match.away_score}')
            
            self.stdout.write('\nHome team statistics:')
            self.stdout.write(f'Possession: {simulation.match_stats["home"]["possession"]}%')
            self.stdout.write(f'Shots (on target): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]})')
            self.stdout.write(f'Corners: {simulation.match_stats["home"]["corners"]}')
            self.stdout.write(f'Fouls: {simulation.match_stats["home"]["fouls"]}')
            self.stdout.write(f'Attacks (dangerous): {simulation.match_stats["home"]["attacks"]} ({simulation.match_stats["home"]["dangerous_attacks"]})')
            
            self.stdout.write('\nAway team statistics:')
            self.stdout.write(f'Possession: {simulation.match_stats["away"]["possession"]}%')
            self.stdout.write(f'Shots (on target): {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
            self.stdout.write(f'Corners: {simulation.match_stats["away"]["corners"]}')
            self.stdout.write(f'Fouls: {simulation.match_stats["away"]["fouls"]}')
            self.stdout.write(f'Attacks (dangerous): {simulation.match_stats["away"]["attacks"]} ({simulation.match_stats["away"]["dangerous_attacks"]})')

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'\nError occurred: {str(e)}'))

# --- ????? ????? C:\realfootballsim\matches\management\commands\test_match.py ---


# --- ?????? ????? C:\realfootballsim\matches\migrations\0001_initial.py ---

# Generated by Django 5.0.1 on 2024-12-07 04:02

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('clubs', '0001_initial'),
        ('players', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Match',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('datetime', models.DateTimeField(blank=True, db_index=True, null=True, verbose_name='Match Date and Time')),
                ('processed', models.BooleanField(db_index=True, default=False, help_text='Indicates if match has been processed')),
                ('home_score', models.PositiveIntegerField(default=0)),
                ('away_score', models.PositiveIntegerField(default=0)),
                ('status', models.CharField(choices=[('scheduled', 'Scheduled'), ('in_progress', 'In Progress'), ('finished', 'Finished'), ('cancelled', 'Cancelled')], db_index=True, default='scheduled', max_length=20)),
                ('home_lineup', models.JSONField(blank=True, null=True)),
                ('away_lineup', models.JSONField(blank=True, null=True)),
                ('away_team', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='away_matches', to='clubs.club')),
                ('home_team', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='home_matches', to='clubs.club')),
            ],
        ),
        migrations.CreateModel(
            name='MatchEvent',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('minute', models.PositiveIntegerField()),
                ('event_type', models.CharField(choices=[('goal', 'Goal'), ('yellow_card', 'Yellow Card'), ('red_card', 'Red Card'), ('substitution', 'Substitution')], max_length=20)),
                ('description', models.TextField()),
                ('match', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='events', to='matches.match')),
                ('player', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='players.player')),
            ],
        ),
    ]

# --- ????? ????? C:\realfootballsim\matches\migrations\0001_initial.py ---


# --- ?????? ????? C:\realfootballsim\matches\migrations\0002_alter_matchevent_event_type_alter_matchevent_player.py ---

# Generated by Django 5.0.1 on 2024-12-07 16:48

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('matches', '0001_initial'),
        ('players', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='matchevent',
            name='event_type',
            field=models.CharField(choices=[('goal', 'Goal'), ('yellow_card', 'Yellow Card'), ('red_card', 'Red Card'), ('substitution', 'Substitution'), ('possession', 'Possession Change'), ('miss', 'Miss')], max_length=20),
        ),
        migrations.AlterField(
            model_name='matchevent',
            name='player',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='players.player'),
        ),
    ]

# --- ????? ????? C:\realfootballsim\matches\migrations\0002_alter_matchevent_event_type_alter_matchevent_player.py ---


# --- ?????? ????? C:\realfootballsim\matches\migrations\0003_alter_matchevent_event_type.py ---

# Generated by Django 5.0.1 on 2024-12-07 16:57

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('matches', '0002_alter_matchevent_event_type_alter_matchevent_player'),
    ]

    operations = [
        migrations.AlterField(
            model_name='matchevent',
            name='event_type',
            field=models.CharField(choices=[('goal', 'Goal'), ('miss', 'Miss'), ('possession', 'Possession Change'), ('defense_to_midfield', 'Defense to Midfield Transition'), ('midfield_to_attack', 'Midfield to Attack Transition'), ('attack_to_shot', 'Attack to Shot Opportunity'), ('interception', 'Interception'), ('yellow_card', 'Yellow Card'), ('red_card', 'Red Card'), ('substitution', 'Substitution')], max_length=20),
        ),
    ]

# --- ????? ????? C:\realfootballsim\matches\migrations\0003_alter_matchevent_event_type.py ---


# --- ?????? ????? C:\realfootballsim\matches\migrations\__init__.py ---


# --- ????? ????? C:\realfootballsim\matches\migrations\__init__.py ---


# --- ?????? ????? C:\realfootballsim\matches\static\matches\js\team_selection.js ---

document.addEventListener('DOMContentLoaded', function() {
    const pitch = document.getElementById('pitch');
    const playerList = document.getElementById('playerList');
    const resetButton = document.getElementById('resetTeam');
    const saveStatus = document.getElementById('saveStatus');
    const tacticSelect = document.getElementById('tacticSelect');
    const clubId = document.getElementById('clubId').value;
    let saveTimeout;

    // Создание слотов для игроков на поле
    const positions = [
        {top: '10%', left: '50%'},  // GK
        {top: '30%', left: '20%'}, {top: '30%', left: '40%'},  // DEF
        {top: '30%', left: '60%'}, {top: '30%', left: '80%'},
        {top: '60%', left: '30%'}, {top: '60%', left: '50%'},  // MID
        {top: '60%', left: '70%'},
        {top: '80%', left: '30%'}, {top: '80%', left: '50%'},  // FWD
        {top: '80%', left: '70%'}
    ];

    positions.forEach((pos, index) => {
        const slot = document.createElement('div');
        slot.className = 'player-slot';
        slot.style.top = pos.top;
        slot.style.left = pos.left;
        slot.dataset.position = index;
        pitch.appendChild(slot);
    });

    function autoSave() {
        clearTimeout(saveTimeout);
        saveStatus.textContent = 'Saving...';
        saveTimeout = setTimeout(() => {
            saveTeamSelection();
        }, 1000); // Сохраняем через 1 секунду после последнего изменения
    }

    function saveTeamSelection() {
        const selection = {};
        document.querySelectorAll('.player-slot').forEach(slot => {
            const playerElem = slot.querySelector('.player-item');
            if (playerElem) {
                selection[slot.dataset.position] = playerElem.dataset.playerId;
            }
        });

        // Добавляем тактику к отправляемым данным
        const tactic = tacticSelect.value;

        const payload = {
            lineup: selection,
            tactic: tactic
        };

        fetch(`/clubs/${clubId}/save-team-lineup/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                saveStatus.textContent = 'Saved';
                setTimeout(() => {
                    saveStatus.textContent = '';
                }, 2000);
            } else {
                saveStatus.textContent = 'Save failed';
            }
        })
        .catch(error => {
            saveStatus.textContent = 'Save failed';
        });
    }

    function loadPreviousSelection() {
        fetch(`/clubs/${clubId}/get-team-lineup/`)
            .then(response => response.json())
            .then(data => {
                if (data.lineup) {
                    Object.entries(data.lineup).forEach(([position, playerId]) => {
                        const slot = document.querySelector(`.player-slot[data-position="${position}"]`);
                        const player = document.querySelector(`.player-item[data-player-id="${playerId}"]`);
                        if (slot && player) {
                            slot.appendChild(player);
                        }
                    });
                }

                // Если в данных есть тактика, выбираем её
                if (data.tactic) {
                    tacticSelect.value = data.tactic;
                }
            });
    }

    function resetSelection() {
        document.querySelectorAll('.player-slot .player-item').forEach(player => {
            playerList.appendChild(player);
        });
        autoSave();
    }

    function initializeSortable() {
        new Sortable(playerList, {
            group: 'shared',
            animation: 150,
            onEnd: autoSave
        });

        document.querySelectorAll('.player-slot').forEach(slot => {
            new Sortable(slot, {
                group: 'shared',
                animation: 150,
                onAdd: function(evt) {
                    const slotElement = evt.to;
                    const newPlayer = evt.item;

                    // Удаляем всех существующих игроков из слота
                    slotElement.querySelectorAll('.player-item').forEach(player => {
                        if (player !== newPlayer) {
                            playerList.appendChild(player);
                        }
                    });

                    // Перемещаем нового игрока в слот
                    slotElement.appendChild(newPlayer);

                    autoSave();
                }
            });
        });
    }

    fetch(`/clubs/${clubId}/get-players/`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(players => {
            if (!Array.isArray(players) || players.length === 0) {
                playerList.textContent = 'No players available';
                return;
            }
            players.forEach(player => {
                const playerElem = document.createElement('div');
                playerElem.className = 'player-item';
                playerElem.textContent = `${player.name} (${player.position})`;
                playerElem.dataset.playerId = player.id;
                playerList.appendChild(playerElem);
            });

            initializeSortable();
            loadPreviousSelection();
        })
        .catch(error => {
            playerList.textContent = 'Error loading players. Please try again later.';
        });

    resetButton.addEventListener('click', resetSelection);

    tacticSelect.addEventListener('change', autoSave);

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
});

# --- ????? ????? C:\realfootballsim\matches\static\matches\js\team_selection.js ---


# --- ?????? ????? C:\realfootballsim\matches\templates\matches\create_match.html ---

{% extends 'core/base.html' %}

{% block content %}
<div class="container">
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title h4 mb-0">Create New Match</h2>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        
                        {% for field in form %}
                        <div class="mb-3">
                            <label for="{{ field.id_for_label }}" class="form-label">
                                {{ field.label }}
                            </label>
                            {% if field.field.widget.input_type == 'select' %}
                                <select name="{{ field.name }}" id="{{ field.id_for_label }}" 
                                        class="form-select {% if field.errors %}is-invalid{% endif %}">
                                    {% for value, label in field.field.choices %}
                                        <option value="{{ value }}"
                                                {% if value == field.value|stringformat:"s" %}selected{% endif %}>
                                            {{ label }}
                                        </option>
                                    {% endfor %}
                                </select>
                            {% else %}
                                {{ field.as_widget }}
                            {% endif %}
                            {% if field.errors %}
                                <div class="invalid-feedback">
                                    {{ field.errors|join:", " }}
                                </div>
                            {% endif %}
                            {% if field.help_text %}
                                <small class="form-text text-muted">{{ field.help_text }}</small>
                            {% endif %}
                        </div>
                        {% endfor %}
                        
                        <div class="d-grid gap-2">
                            <button type="submit" class="btn btn-primary">Create Match</button>
                            <a href="{% url 'home' %}" class="btn btn-outline-secondary">Back to Home</a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\matches\templates\matches\create_match.html ---


# --- ?????? ????? C:\realfootballsim\matches\templates\matches\match_detail.html ---

{% extends 'core/base.html' %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header">
                    <h2 class="mb-0">Match Details</h2>
                </div>
                <div class="card-body">
                    <div class="text-center mb-4">
                        <div class="row align-items-center">
                            <div class="col-md-5">
                                <a href="{% url 'clubs:club_detail' match.home_team.id %}" class="text-decoration-none">
                                    <h3>{{ match.home_team.name }}</h3>
                                    {% if match.home_team.is_bot %}
                                        <span class="badge bg-secondary">Bot</span>
                                    {% endif %}
                                </a>
                            </div>
                            <div class="col-md-2">
                                {% if match.status == 'finished' %}
                                    <h3 class="score">{{ match.home_score }} - {{ match.away_score }}</h3>
                                {% else %}
                                    <h3>vs</h3>
                                {% endif %}
                            </div>
                            <div class="col-md-5">
                                <a href="{% url 'clubs:club_detail' match.away_team.id %}" class="text-decoration-none">
                                    <h3>{{ match.away_team.name }}</h3>
                                    {% if match.away_team.is_bot %}
                                        <span class="badge bg-secondary">Bot</span>
                                    {% endif %}
                                </a>
                            </div>
                        </div>
                    </div>

                    <div class="row mb-4">
                        <div class="col-md-6">
                            <p><strong>Date:</strong> {{ match.date }}</p>
                            <p><strong>Status:</strong> 
                                <span class="badge {% if match.status == 'finished' %}bg-success{% elif match.status == 'in_progress' %}bg-warning{% else %}bg-secondary{% endif %}">
                                    {{ match.get_status_display }}
                                </span>
                            </p>
                        </div>
                        <div class="col-md-6 text-md-end">
                            {% if match.status == 'scheduled' and user.is_staff %}
                                <form method="post" class="d-inline">
                                    {% csrf_token %}
                                    <button type="submit" class="btn btn-primary">Simulate Match</button>
                                </form>
                            {% endif %}
                        </div>
                    </div>

                    <h4>Match Events</h4>
                    <div class="list-group">
                        {% for event in match.events.all %}
                            <div class="list-group-item">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <strong>{{ event.minute }}'</strong> - 
                                        {{ event.get_event_type_display }}: {{ event.description }}
                                    </div>
                                </div>
                            </div>
                        {% empty %}
                            <div class="list-group-item text-center text-muted">
                                No events recorded
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>

            <div class="text-center">
                <a href="{% url 'home' %}" class="btn btn-outline-primary">Back to Home</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\matches\templates\matches\match_detail.html ---


# --- ?????? ????? C:\realfootballsim\matches\templates\matches\team_selection.html ---

{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Selection for {{ club.name }}</title>
    <style>
        .pitch {
            width: 600px;
            height: 400px;
            background-color: #4CAF50;
            position: relative;
            margin: 20px auto;
        }
        .player-slot {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
        }
        .player-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        .player-item {
            width: 100px;
            height: 50px;
            background-color: #f1f1f1;
            margin: 5px;
            padding: 5px;
            cursor: move;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            text-align: center;
        }
        .tactics-section {
            text-align: center;
            margin-top: 20px;
        }
        .tactics-section select {
            font-size: 14px;
            padding: 5px;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Select Your Team Lineup for {{ club.name }}</h1>

    <div class="tactics-section">
        <label for="tacticSelect"><strong>Select Tactic:</strong></label>
        <select id="tacticSelect">
            <option value="attacking">Attacking</option>
            <option value="balanced" selected>Balanced</option>
            <option value="defensive">Defensive</option>
        </select>
    </div>
    
    <div class="pitch" id="pitch">
        <!-- Player slots will be added here dynamically -->
    </div>

    <h2 style="text-align: center;">Available Players</h2>
    <div class="player-list" id="playerList">
        <!-- Available players will be added here dynamically -->
    </div>

    <!-- Добавляем скрытое поле с ID клуба -->
    <input type="hidden" id="clubId" value="{{ club.id }}">

    <button id="resetTeam" style="display:block;margin:20px auto;">Reset Selection</button>
    <span id="saveStatus" style="display:block;text-align:center;"></span>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script src="{% static 'js/team_selection.js' %}"></script>
</body>
</html>

# --- ????? ????? C:\realfootballsim\matches\templates\matches\team_selection.html ---


# --- ?????? ????? C:\realfootballsim\matches\admin.py ---

from django.contrib import admin
from django.contrib.admin import DateFieldListFilter
from .models import Match, MatchEvent

@admin.register(Match)
class MatchAdmin(admin.ModelAdmin):
    list_display = ('home_team', 'away_team', 'datetime', 'status', 'processed')
    list_filter = ('status', ('datetime', DateFieldListFilter), 'processed')
    search_fields = ('home_team__name', 'away_team__name')

@admin.register(MatchEvent)
class MatchEventAdmin(admin.ModelAdmin):
    list_display = ('match', 'minute', 'event_type', 'player')
    list_filter = ('event_type', 'match')
    search_fields = ('match__home_team__name', 'match__away_team__name', 'player__first_name', 'player__last_name')

# --- ????? ????? C:\realfootballsim\matches\admin.py ---


# --- ?????? ????? C:\realfootballsim\matches\apps.py ---

from django.apps import AppConfig


class MatchesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'matches'

# --- ????? ????? C:\realfootballsim\matches\apps.py ---


# --- ?????? ????? C:\realfootballsim\matches\match_preparation.py ---

from typing import Dict, List, Tuple
from .models import Match
from clubs.models import Club
from players.models import Player

class PreMatchPreparation:
    """Класс для подготовки и анализа матча перед его началом"""
    
    # Веса для расчета силы игроков по позициям
    DEFENDER_WEIGHTS = {
        'marking': 0.3,
        'tackling': 0.3,
        'strength': 0.2,
        'positioning': 0.2
    }
    
    MIDFIELDER_WEIGHTS = {
        'passing': 0.3,
        'vision': 0.3,
        'stamina': 0.2,
        'work_rate': 0.2
    }
    
    FORWARD_WEIGHTS = {
        'finishing': 0.3,
        'dribbling': 0.3,
        'long_range': 0.2,
        'accuracy': 0.2
    }
    
    GOALKEEPER_WEIGHTS = {
        'reflexes': 0.25,
        'handling': 0.25,
        'positioning': 0.2,
        'aerial': 0.1,
        'command': 0.1,
        'shot_reading': 0.1
    }

    def __init__(self, match: Match):
        self.match = match
        self.home_team = match.home_team
        self.away_team = match.away_team
        
        # Проверяем и автоматически формируем составы если нужно
        self.home_lineup = self.match.home_lineup if self.match.home_lineup else self.auto_select_lineup(self.home_team)
        self.away_lineup = self.match.away_lineup if self.match.away_lineup else self.auto_select_lineup(self.away_team)
        
        # Сохраняем сформированные составы в матч
        if not self.match.home_lineup:
            self.match.home_lineup = self.home_lineup
        if not self.match.away_lineup:
            self.match.away_lineup = self.away_lineup
        self.match.save()
        
        # Результаты проверок и расчетов будут храниться здесь
        self.validation_results = {
            'home_valid': False,
            'away_valid': False,
            'errors': []
        }
        
        # Расчетные параметры команд
        self.team_strengths = {
            'home': 0,
            'away': 0
        }
        
        # Начальные параметры матча
        self.match_parameters = {
            'home': {
                'players_condition': {},  # Физическая готовность каждого игрока (100%)
                'team_attack': 0,        # Атакующий потенциал команды
                'team_defense': 0,       # Оборонительный потенциал команды
                'team_midfield': 0,      # Контроль средней линии
                'goalkeeper_strength': 0  # Сила вратаря
            },
            'away': {
                'players_condition': {},  # Физическая готовность каждого игрока (100%)
                'team_attack': 0,        # Атакующий потенциал команды
                'team_defense': 0,       # Оборонительный потенциал команды
                'team_midfield': 0,      # Контроль средней линии
                'goalkeeper_strength': 0  # Сила вратаря
            }
        }

    def auto_select_lineup(self, team: Club) -> dict:
        """
        Автоматически формирует состав команды в формате 4-4-2
        
        Args:
            team: Club - команда для которой формируется состав
            
        Returns:
            dict: словарь с расстановкой игроков
        """
        players = team.player_set.all()
        lineup = {}
        
        # Сначала выбираем вратаря
        goalkeeper = players.filter(position='Goalkeeper').first()
        if goalkeeper:
            lineup['0'] = goalkeeper.id
        
        # Выбираем защитников (4 позиции)
        defenders = players.filter(
            position__in=['Right Back', 'Left Back', 'Center Back']
        )[:4]
        for i, player in enumerate(defenders, 1):
            lineup[str(i)] = player.id
        
        # Выбираем полузащитников (4 позиции)
        midfielders = players.filter(
            position__icontains='Midfielder'
        )[:4]
        for i, player in enumerate(midfielders, 5):
            lineup[str(i)] = player.id
        
        # Выбираем нападающих (2 позиции)
        forwards = players.filter(
            position='Center Forward'
        )[:2]
        for i, player in enumerate(forwards, 9):
            lineup[str(i)] = player.id
            
        return lineup

    def validate_lineup(self, lineup: Dict, team: Club) -> bool:
        """
        Проверяет валидность состава команды
        
        Args:
            lineup: Dict - словарь с расстановкой игроков
            team: Club - команда для проверки
        
        Returns:
            bool: True если состав валиден, False если есть ошибки
        """
        errors = []
        
        # Проверка количества игроков
        if len(lineup) != 11:
            errors.append(f"Команда {team.name} должна иметь ровно 11 игроков в составе")
            return False
            
        position_counts = {
            'Goalkeeper': 0,
            'Defender': 0,
            'Midfielder': 0,
            'Forward': 0
        }
        
        # Проверяем каждую позицию в составе
        for pos, player_id in lineup.items():
            try:
                player = Player.objects.get(id=player_id)
                
                # Проверяем позицию игрока
                if player.position == 'Goalkeeper':
                    position_counts['Goalkeeper'] += 1
                elif 'Back' in player.position or player.position == 'Center Back':
                    position_counts['Defender'] += 1
                elif 'Midfielder' in player.position:
                    position_counts['Midfielder'] += 1
                elif 'Forward' in player.position:
                    position_counts['Forward'] += 1
                    
            except Player.DoesNotExist:
                errors.append(f"Игрок с ID {player_id} не найден")
                return False
        
        # Проверяем количество игроков на каждой позиции
        if position_counts['Goalkeeper'] != 1:
            errors.append(f"В составе команды {team.name} должен быть ровно 1 вратарь")
            return False
            
        if not (3 <= position_counts['Defender'] <= 5):
            errors.append(f"В составе команды {team.name} должно быть от 3 до 5 защитников")
            return False
            
        if not (2 <= position_counts['Midfielder'] <= 5):
            errors.append(f"В составе команды {team.name} должно быть от 2 до 5 полузащитников")
            return False
            
        if not (1 <= position_counts['Forward'] <= 4):
            errors.append(f"В составе команды {team.name} должно быть от 1 до 4 нападающих")
            return False
            
        # Добавляем ошибки в общий список
        if errors:
            self.validation_results['errors'].extend(errors)
            return False
            
        return True

    def calculate_player_strength(self, player: Player) -> float:
        """
        Рассчитывает силу игрока на его позиции
        
        Args:
            player: Player - игрок для расчета
            
        Returns:
            float: значение силы игрока (0-100)
        """
        if player.position == 'Goalkeeper':
            weights = self.GOALKEEPER_WEIGHTS
            attributes = {
                'reflexes': player.reflexes,
                'handling': player.handling,
                'positioning': player.positioning,
                'aerial': player.aerial,
                'command': player.command,
                'shot_reading': player.shot_reading
            }
        elif 'Back' in player.position or player.position == 'Center Back':
            weights = self.DEFENDER_WEIGHTS
            attributes = {
                'marking': player.marking,
                'tackling': player.tackling,
                'strength': player.strength,
                'positioning': player.positioning
            }
        elif 'Midfielder' in player.position:
            weights = self.MIDFIELDER_WEIGHTS
            attributes = {
                'passing': player.passing,
                'vision': player.vision,
                'stamina': player.stamina,
                'work_rate': player.work_rate
            }
        else:  # Forwards
            weights = self.FORWARD_WEIGHTS
            attributes = {
                'finishing': player.finishing,
                'dribbling': player.dribbling,
                'long_range': player.long_range,
                'accuracy': player.accuracy
            }
        
        # Рассчитываем взвешенную сумму характеристик
        strength = sum(weights[attr] * value for attr, value in attributes.items())
        return round(strength, 2)

    def calculate_team_strength(self, lineup: Dict, team: Club, is_home: bool = False) -> float:
        """
        Рассчитывает общую силу команды
        
        Args:
            lineup: Dict - словарь с расстановкой игроков
            team: Club - команда
            is_home: bool - играет ли команда дома
            
        Returns:
            float: общая сила команды (0-100)
        """
        total_strength = 0
        position_counts = {
            'Goalkeeper': 0,
            'Defender': 0,
            'Midfielder': 0,
            'Forward': 0
        }

        # Рассчитываем силу каждого игрока и суммируем
        for player_id in lineup.values():
            try:
                player = Player.objects.get(id=player_id)
                player_strength = self.calculate_player_strength(player)
                total_strength += player_strength

                # Подсчитываем количество игроков на каждой позиции
                if player.position == 'Goalkeeper':
                    position_counts['Goalkeeper'] += 1
                elif 'Back' in player.position or player.position == 'Center Back':
                    position_counts['Defender'] += 1
                elif 'Midfielder' in player.position:
                    position_counts['Midfielder'] += 1
                else:
                    position_counts['Forward'] += 1

            except Player.DoesNotExist:
                continue

        # Проверяем баланс состава
        if position_counts['Goalkeeper'] != 1:
            return 0  # Неверное количество вратарей
        if position_counts['Defender'] < 3 or position_counts['Defender'] > 5:
            return 0  # Слишком мало или много защитников
        if position_counts['Midfielder'] < 2 or position_counts['Midfielder'] > 5:
            return 0  # Слишком мало или много полузащитников
        if position_counts['Forward'] < 1 or position_counts['Forward'] > 4:
            return 0  # Слишком мало или много нападающих

        # Рассчитываем среднюю силу команды
        team_strength = total_strength / 11
        
        # Добавляем бонус за домашнее поле (+10%)
        if is_home:
            team_strength *= 1.1
            
        return round(team_strength, 2)

    def _calculate_initial_parameters(self, team_type: str):
        """
        Рассчитывает начальные параметры для команды
        
        Args:
            team_type: str - 'home' или 'away'
        """
        lineup = self.home_lineup if team_type == 'home' else self.away_lineup
        parameters = self.match_parameters[team_type]
        
        attack_sum = 0
        defense_sum = 0
        midfield_sum = 0
        attacker_count = 0
        defender_count = 0
        midfielder_count = 0
        
        # Проходим по всем игрокам в составе
        for position, player_id in lineup.items():
            player = Player.objects.get(id=player_id)
            
            # Устанавливаем начальную физическую готовность
            parameters['players_condition'][player_id] = 100
            
            if player.position == 'Goalkeeper':
                # Рассчитываем силу вратаря
                parameters['goalkeeper_strength'] = self.calculate_player_strength(player)
                
            elif 'Back' in player.position or player.position == 'Center Back':
                # Защитники
                defense_sum += (
                    player.marking * 0.3 +
                    player.tackling * 0.3 +
                    player.strength * 0.2 +
                    player.positioning * 0.2
                )
                defender_count += 1
                
            elif 'Midfielder' in player.position:
                # Полузащитники
                midfield_sum += (
                    player.passing * 0.3 +
                    player.vision * 0.3 +
                    player.work_rate * 0.2 +
                    player.stamina * 0.2
                )
                midfielder_count += 1
                
                # Атакующие полузащитники вносят вклад в атаку
                if 'Attacking' in player.position:
                    attack_sum += (
                        player.finishing * 0.2 +
                        player.long_range * 0.2 +
                        player.accuracy * 0.1
                    )
                    attacker_count += 0.5  # Считаем как пол-нападающего
                    
            else:
                # Нападающие
                attack_sum += (
                    player.finishing * 0.3 +
                    player.dribbling * 0.3 +
                    player.long_range * 0.2 +
                    player.accuracy * 0.2
                )
                attacker_count += 1
        
        # Рассчитываем средние значения
        parameters['team_attack'] = round(attack_sum / max(attacker_count, 1), 2)
        parameters['team_defense'] = round(defense_sum / defender_count, 2)
        parameters['team_midfield'] = round(midfield_sum / midfielder_count, 2)
        
        # Применяем домашний бонус
        if team_type == 'home':
            parameters['team_attack'] *= 1.1
            parameters['team_defense'] *= 1.1
            parameters['team_midfield'] *= 1.1

    def prepare_match(self) -> bool:
        """
        Основной метод подготовки матча
        
        Returns:
            bool: True если подготовка успешна, False если есть ошибки
        """
        # Проверяем составы
        self.validation_results['home_valid'] = self.validate_lineup(self.home_lineup, self.home_team)
        self.validation_results['away_valid'] = self.validate_lineup(self.away_lineup, self.away_team)
        
        # Если есть ошибки в составах, дальнейшая подготовка невозможна
        if not (self.validation_results['home_valid'] and self.validation_results['away_valid']):
            return False
            
        # Рассчитываем силу команд
        self.team_strengths['home'] = self.calculate_team_strength(
            self.home_lineup, 
            self.home_team, 
            is_home=True
        )
        self.team_strengths['away'] = self.calculate_team_strength(
            self.away_lineup, 
            self.away_team, 
            is_home=False
        )
        
        # Проверяем валидность рассчитанных сил
        if self.team_strengths['home'] == 0 or self.team_strengths['away'] == 0:
            self.validation_results['errors'].append("Ошибка в расчете сил команд - неверный баланс состава")
            return False
        
        # Рассчитываем начальные параметры матча
        self._calculate_initial_parameters('home')
        self._calculate_initial_parameters('away')
        
        return True

    def get_validation_errors(self) -> List[str]:
        """Возвращает список ошибок валидации"""
        return self.validation_results['errors']

# --- ????? ????? C:\realfootballsim\matches\match_preparation.py ---


# --- ?????? ????? C:\realfootballsim\matches\match_simulation.py ---

from django.utils import timezone
from .models import Match, MatchEvent
from .player_agent import PlayerAgent
import random

class MatchSimulation:
    def __init__(self, match):
        self.match = match
        
        # Предположим, что тактика команд может быть сохранена в модели,
        # или в данном примере просто зададим их явно.
        # В реальности вы можете загрузить тактику из базы, параметров матча или выбора пользователя.
        self.match_stats = {
            'home': {
                'possession': 50, 
                'shots': 0, 
                'goals': 0,
                'passes': 0,
                'tackles': 0,
                'team_attack': self._calculate_team_parameter(match.home_team, 'attack'),
                'team_defense': self._calculate_team_parameter(match.home_team, 'defense'),
                'team_midfield': self._calculate_team_parameter(match.home_team, 'midfield'),
                'tactics': 'attacking'  # Пример: домашняя команда играет атакующе
            },
            'away': {
                'possession': 50, 
                'shots': 0, 
                'goals': 0,
                'passes': 0,
                'tackles': 0,
                'team_attack': self._calculate_team_parameter(match.away_team, 'attack'),
                'team_defense': self._calculate_team_parameter(match.away_team, 'defense'),
                'team_midfield': self._calculate_team_parameter(match.away_team, 'midfield'),
                'tactics': 'defensive' # Пример: гостевая команда обороняется
            }
        }

        self.player_agents = {'home': {}, 'away': {}}
        for team_type in ['home', 'away']:
            team = self.match.home_team if team_type == 'home' else self.match.away_team
            players = team.player_set.all()
            for player in players:
                agent = PlayerAgent(player)
                self.player_agents[team_type][player.id] = agent

        self.ball_owner = None
        self.current_zone = None

        self._setup_moments()
        self.match.home_score = 0
        self.match.away_score = 0

    def _calculate_team_parameter(self, team, parameter_type):
        players = team.player_set.all()
        total = 0
        count = 0
        
        for player in players:
            # Учитываем опыт, например +1% за единицу опыта
            experience_multiplier = 1 + player.experience * 0.01

            if parameter_type == 'attack':
                if player.position in ['Center Forward', 'Attacking Midfielder']:
                    base_value = player.finishing + player.heading + player.long_range
                    weight = 1.5
                else:
                    base_value = player.finishing + player.long_range
                    weight = 1.0
            elif parameter_type == 'defense':
                if player.position in ['Center Back', 'Right Back', 'Left Back', 'Defensive Midfielder']:
                    base_value = player.marking + player.tackling + player.heading
                    weight = 1.5
                else:
                    base_value = player.marking + player.tackling
                    weight = 1.0
            else:  # midfield
                if player.position in ['Central Midfielder', 'Defensive Midfielder', 'Attacking Midfielder']:
                    base_value = player.passing + player.vision + player.work_rate
                    weight = 1.5
                else:
                    base_value = player.passing + player.work_rate
                    weight = 1.0

            # Применяем опытный множитель
            final_value = base_value * experience_multiplier

            total += final_value * weight
            count += weight
            
        return round(total / count) if count > 0 else 50

    def create_match_event(self, minute, event_type, agent, description):
        player_model = agent.player_model if agent else None
        MatchEvent.objects.create(
            match=self.match,
            minute=minute,
            event_type=event_type,
            player=player_model,
            description=description
        )

    def get_random_agent(self, team_type, positions=None):
        agents = list(self.player_agents[team_type].values())
        if positions:
            agents = [agent for agent in agents if any(pos in agent.position for pos in positions)]
        return random.choice(agents) if agents else None

    def set_ball_owner(self, team_type, player_id):
        self.ball_owner = (team_type, player_id)

    def clear_ball_owner(self):
        self.ball_owner = None
        self.current_zone = None

    def assign_ball_to_defender(self, team_type):
        positions_priority = ['Defensive Midfielder', 'Center Back', 'Right Back', 'Left Back', 'Central Midfielder']
        candidates = []
        for pid, agent in self.player_agents[team_type].items():
            if any(pos in agent.position for pos in positions_priority):
                candidates.append(pid)
        if candidates:
            chosen = random.choice(candidates)
            self.set_ball_owner(team_type, chosen)
            self.current_zone = 'defense'
        else:
            all_pids = list(self.player_agents[team_type].keys())
            chosen = random.choice(all_pids)
            self.set_ball_owner(team_type, chosen)
            self.current_zone = 'defense'

    def advance_zone(self, team_type):
        if self.current_zone == 'defense':
            self.current_zone = 'midfield'
        elif self.current_zone == 'midfield':
            self.current_zone = 'attack'

    def _apply_tactics_to_pass(self, team_type, pass_success, intercept_chance):
        tactics = self.match_stats[team_type]['tactics']

        if tactics == 'attacking':
            pass_success = min(1.0, pass_success + 0.1)
            intercept_chance = min(1.0, intercept_chance + 0.1)
        elif tactics == 'defensive':
            pass_success = max(0.0, pass_success - 0.1)
            intercept_chance = min(1.0, intercept_chance + 0.05)
        # balanced - без изменений

        return pass_success, intercept_chance

    def _apply_tactics_to_shot(self, team_type, shot_chance):
        tactics = self.match_stats[team_type]['tactics']

        if tactics == 'attacking':
            shot_chance = min(1.0, shot_chance + 0.1)
        elif tactics == 'defensive':
            shot_chance = max(0.0, shot_chance - 0.05)
        return shot_chance

    def attempt_pass(self, minute, team_type):
        if not self.ball_owner:
            return False
        owner_team, owner_pid = self.ball_owner
        if owner_team != team_type:
            return False

        passer_agent = self.player_agents[team_type][owner_pid]
        pass_success = min(1.0, (self.match_stats[team_type]['team_midfield']/100)*1.5)

        defending_team = 'away' if team_type == 'home' else 'home'
        defense_factor = self.match_stats[defending_team]['team_defense']
        attack_factor = self.match_stats[team_type]['team_attack']
        intercept_chance = 0.3 if defense_factor > attack_factor else 0.15

        # Применяем тактику к пасу
        pass_success, intercept_chance = self._apply_tactics_to_pass(team_type, pass_success, intercept_chance)

        if random.random() < intercept_chance:
            self.match_stats[defending_team]['tackles'] += 1
            self.clear_ball_owner()
            self.create_match_event(minute, 'info', None, "Pass intercepted by defenders!")
            return False

        if random.random() < pass_success:
            self.match_stats[team_type]['passes'] += 1
            self.create_match_event(minute, 'info', passer_agent, f"{passer_agent.full_name} passes forward")
            self.advance_zone(team_type)
            new_owner = self.get_random_agent(team_type)
            if new_owner:
                self.set_ball_owner(team_type, new_owner.player_model.id)
            return True
        else:
            self.clear_ball_owner()
            self.create_match_event(minute, 'info', passer_agent, f"{passer_agent.full_name}'s pass goes wide")
            return False

    def attempt_shot(self, minute, team_type):
        if not self.ball_owner:
            return False
        owner_team, owner_pid = self.ball_owner
        if owner_team != team_type:
            return False
            
        shooter = self.player_agents[team_type][owner_pid]
        shot_chance = min(1.0, (self.match_stats[team_type]['team_attack']/100)*1.2)

        # Применяем тактику к удару
        shot_chance = self._apply_tactics_to_shot(team_type, shot_chance)

        defending_team = 'away' if team_type == 'home' else 'home'

        # Если соперник оборонительный, выше шанс блока
        if self.match_stats[defending_team]['tactics'] == 'defensive':
            block_chance = 0.6
        else:
            block_chance = 0.5

        if random.random() < block_chance:
            self.match_stats[defending_team]['tackles'] += 1
            self.clear_ball_owner()
            self.create_match_event(minute, 'info', None, "Shot blocked by a defender!")
            return False

        if random.random() < shot_chance:
            self.match_stats[team_type]['goals'] += 1
            self.match_stats[team_type]['shots'] += 1
            if team_type == 'home':
                self.match.home_score += 1
            else:
                self.match.away_score += 1
            self.match.save()

            self.create_match_event(minute, 'goal', shooter, f"GOAL! {shooter.full_name} scores!")
            self.clear_ball_owner()
            return True
        else:
            self.match_stats[team_type]['shots'] += 1
            self.create_match_event(minute, 'info', shooter, f"{shooter.full_name}'s shot goes wide")
            self.clear_ball_owner()
            return False

    def _determine_attacking_team(self):
        home_mid = self.match_stats['home']['team_midfield']
        away_mid = self.match_stats['away']['team_midfield']
        if (home_mid + away_mid) == 0:
            return 'home' if random.random() < 0.5 else 'away'
        home_chance = home_mid / (home_mid + away_mid)
        return 'home' if random.random() < home_chance else 'away'

    def _setup_moments(self):
        base_min, base_max = 10, 20
        home_strength = (self.match_stats['home']['team_attack'] + self.match_stats['home']['team_midfield']) / 2
        away_strength = (self.match_stats['away']['team_attack'] + self.match_stats['away']['team_midfield']) / 2
        
        home_factor = min(home_strength / 100, 1.0)
        away_factor = min(away_strength / 100, 1.0)
        
        home_chances = int(base_min + (base_max - base_min)*home_factor)
        away_chances = int(base_min + (base_max - base_min)*away_factor)

        all_minutes = list(range(1, 90))
        random.shuffle(all_minutes)

        self.home_moments_minutes = sorted(all_minutes[:home_chances])
        self.away_moments_minutes = sorted(all_minutes[home_chances:home_chances+away_chances])

    def simulate_minute(self, minute):
        if minute in self.home_moments_minutes:
            attacking_team = 'home'
        elif minute in self.away_moments_minutes:
            attacking_team = 'away'
        else:
            return

        self.create_match_event(minute, 'info', None, "==============================")
        self.create_match_event(minute, 'info', None, f"MOMENT at minute {minute}: {attacking_team.upper()} tries to attack!")
        self.create_match_event(minute, 'info', None, "==============================")

        self.assign_ball_to_defender(attacking_team)

        if self.ball_owner:
            owner_team, owner_pid = self.ball_owner
            owner_agent = self.player_agents[owner_team][owner_pid]
            self.create_match_event(minute, 'info', None, f"Ball currently owned by {owner_team.upper()} player {owner_agent.full_name} in {self.current_zone} zone.")

        if not self.attempt_pass(minute, attacking_team):
            return

        for _ in range(3):
            if not self.ball_owner or self.ball_owner[0] != attacking_team:
                break
            if self.current_zone == 'attack':
                self.attempt_shot(minute, attacking_team)
                break
            else:
                if not self.attempt_pass(minute, attacking_team):
                    break

    def simulate_match(self):
        print("\n=== MATCH START ===\n")
        print(f"Match: {self.match.home_team.name} vs {self.match.away_team.name}")

        self.match.home_score = 0
        self.match.away_score = 0
        self.match.status = 'in_progress'
        self.match.save()
        
        for minute in range(90):
            if minute % 5 == 0:
                print(f"\n=== MINUTE {minute} ===")
                print(f"Score: {self.match.home_score} - {self.match.away_score}")
            
            self.simulate_minute(minute)
            
        self.match.status = 'finished'
        self.match.save()

        print("\n=== FINAL STATISTICS ===")
        print(f"Final score: {self.match.home_score} - {self.match.away_score}")
        print(f"Shots: {self.match_stats['home']['shots']} - {self.match_stats['away']['shots']}")
        print(f"Passes: {self.match_stats['home']['passes']} - {self.match_stats['away']['passes']}")
        print(f"Tackles: {self.match_stats['home']['tackles']} - {self.match_stats['away']['tackles']}")

def simulate_match(match_id: int):
    match = Match.objects.get(id=match_id)
    simulation = MatchSimulation(match)
    simulation.simulate_match()

# --- ????? ????? C:\realfootballsim\matches\match_simulation.py ---


# --- ?????? ????? C:\realfootballsim\matches\models.py ---

from django.db import models
from django.conf import settings
from clubs.models import Club
from players.models import Player
from django.utils import timezone

class Match(models.Model):
    home_team = models.ForeignKey(Club, on_delete=models.CASCADE, related_name='home_matches')
    away_team = models.ForeignKey(Club, on_delete=models.CASCADE, related_name='away_matches')
    datetime = models.DateTimeField(
        verbose_name="Match Date and Time",
        db_index=True,
        null=True,
        blank=True
    )
    processed = models.BooleanField(
        default=False,
        db_index=True,
        help_text="Indicates if match has been processed"
    )
    home_score = models.PositiveIntegerField(default=0)
    away_score = models.PositiveIntegerField(default=0)
    status = models.CharField(
        max_length=20,
        choices=[
            ('scheduled', 'Scheduled'),
            ('in_progress', 'In Progress'),
            ('finished', 'Finished'),
            ('cancelled', 'Cancelled')
        ],
        default='scheduled',
        db_index=True
    )
    home_lineup = models.JSONField(null=True, blank=True)
    away_lineup = models.JSONField(null=True, blank=True)

    def __str__(self):
        return f"{self.home_team} vs {self.away_team} - {self.datetime}"


class MatchEvent(models.Model):
    match = models.ForeignKey(Match, on_delete=models.CASCADE, related_name='events')
    minute = models.PositiveIntegerField()
    event_type = models.CharField(max_length=20, choices=[
        ('goal', 'Goal'),
        ('miss', 'Miss'),
        ('possession', 'Possession Change'),
        ('defense_to_midfield', 'Defense to Midfield Transition'),
        ('midfield_to_attack', 'Midfield to Attack Transition'),
        ('attack_to_shot', 'Attack to Shot Opportunity'),
        ('interception', 'Interception'),
        ('yellow_card', 'Yellow Card'),
        ('red_card', 'Red Card'),
        ('substitution', 'Substitution')
    ])
    player = models.ForeignKey(Player, on_delete=models.CASCADE, null=True, blank=True)
    description = models.TextField()

    def __str__(self):
        return f"{self.match} - {self.event_type} at {self.minute}'"

# --- ????? ????? C:\realfootballsim\matches\models.py ---


# --- ?????? ????? C:\realfootballsim\matches\pitch.py ---

import random
from typing import Dict, List, Tuple, Optional
from players.models import Player

class Pitch:
    """
    Класс, представляющий футбольное поле как сетку.
    
    WIDTH = 100: ширина поля в клетках
    HEIGHT = 60: высота поля в клетках
    """
    WIDTH = 100
    HEIGHT = 60
    
    def __init__(self):
        # Позиции игроков в формате {(team_type, player_id): (x, y)}
        self.positions: Dict[Tuple[str, int], Tuple[int, int]] = {}
        # Позиция мяча (x, y)
        self.ball_position: Tuple[int, int] = (self.WIDTH // 2, self.HEIGHT // 2)
        # ID игрока, владеющего мячом
        self.ball_owner: Optional[Tuple[str, int]] = None
        
    def set_initial_positions(self, home_players: List[Player], away_players: List[Player]):
        """
        Расставляет игроков по начальным позициям в зависимости от их ролей.
        """
        # Очищаем текущие позиции
        self.positions.clear()
        
        # Расставляем домашнюю команду (атакует справа налево)
        self._set_team_positions(home_players, 'home')
        # Расставляем гостевую команду (атакует слева направо)
        self._set_team_positions(away_players, 'away')
        
    def _set_team_positions(self, players: List[Player], team_type: str):
        """
        Расставляет одну команду по позициям.
        """
        for player in players:
            x, y = self._get_initial_position(player.position, team_type)
            # Добавляем случайное смещение для разнообразия
            x += random.randint(-5, 5)
            y += random.randint(-3, 3)
            # Проверяем границы поля
            x = max(0, min(self.WIDTH - 1, x))
            y = max(0, min(self.HEIGHT - 1, y))
            self.positions[(team_type, player.id)] = (x, y)
    
    def _get_initial_position(self, position: str, team_type: str) -> Tuple[int, int]:
        """
        Определяет начальную позицию игрока в зависимости от его роли.
        """
        # Базовая x-координата зависит от команды
        if team_type == 'home':
            base_x = self.WIDTH * 3 // 4  # правая половина
        else:
            base_x = self.WIDTH // 4  # левая половина
            
        # Y-координата и смещение по X зависят от позиции игрока
        if 'Goalkeeper' in position:
            return (5 if team_type == 'away' else self.WIDTH - 5, self.HEIGHT // 2)
        elif 'Center Back' in position:
            return (base_x + (-10 if team_type == 'home' else 10), self.HEIGHT // 2)
        elif 'Right Back' in position:
            return (base_x + (-10 if team_type == 'home' else 10), self.HEIGHT * 3 // 4)
        elif 'Left Back' in position:
            return (base_x + (-10 if team_type == 'home' else 10), self.HEIGHT // 4)
        elif 'Defensive Midfielder' in position:
            return (base_x + (-5 if team_type == 'home' else 5), self.HEIGHT // 2)
        elif 'Central Midfielder' in position:
            return (base_x, self.HEIGHT // 2)
        elif 'Right Midfielder' in position:
            return (base_x, self.HEIGHT * 3 // 4)
        elif 'Left Midfielder' in position:
            return (base_x, self.HEIGHT // 4)
        elif 'Attacking Midfielder' in position:
            return (base_x + (5 if team_type == 'home' else -5), self.HEIGHT // 2)
        elif 'Center Forward' in position:
            return (base_x + (10 if team_type == 'home' else -10), self.HEIGHT // 2)
        else:
            return (base_x, self.HEIGHT // 2)

    def move_player(self, team_type: str, player_id: int, dx: int, dy: int) -> bool:
        """
        Перемещает игрока на dx, dy клеток.
        Возвращает True, если перемещение успешно.
        """
        if (team_type, player_id) not in self.positions:
            return False
            
        x, y = self.positions[(team_type, player_id)]
        new_x = max(0, min(self.WIDTH - 1, x + dx))
        new_y = max(0, min(self.HEIGHT - 1, y + dy))
        
        # Проверяем, не занята ли новая позиция
        for pos in self.positions.values():
            if pos == (new_x, new_y):
                return False
                
        self.positions[(team_type, player_id)] = (new_x, new_y)
        
        # Если у игрока был мяч, мяч движется с ним
        if self.ball_owner == (team_type, player_id):
            self.ball_position = (new_x, new_y)
            
        return True
        
    def move_towards(self, team_type: str, player_id: int, target_x: int, target_y: int, 
                    speed: int = 1) -> bool:
        """
        Перемещает игрока в направлении целевой точки.
        """
        if (team_type, player_id) not in self.positions:
            return False
            
        x, y = self.positions[(team_type, player_id)]
        dx = 0
        dy = 0
        
        if x < target_x:
            dx = min(speed, target_x - x)
        elif x > target_x:
            dx = max(-speed, target_x - x)
            
        if y < target_y:
            dy = min(speed, target_y - y)
        elif y > target_y:
            dy = max(-speed, target_y - y)
            
        return self.move_player(team_type, player_id, dx, dy)
        
    def get_distance(self, pos1: Tuple[int, int], pos2: Tuple[int, int]) -> float:
        """
        Вычисляет расстояние между двумя точками на поле.
        """
        x1, y1 = pos1
        x2, y2 = pos2
        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
        
    def get_nearest_players(self, x: int, y: int, team_type: str = None, 
                          max_distance: float = None) -> List[Tuple[Tuple[str, int], float]]:
        """
        Находит ближайших игроков к заданной точке.
        Можно отфильтровать по команде и максимальному расстоянию.
        Возвращает список кортежей ((team_type, player_id), distance).
        """
        players = []
        for (t, pid), pos in self.positions.items():
            if team_type and t != team_type:
                continue
                
            dist = self.get_distance((x, y), pos)
            if max_distance is None or dist <= max_distance:
                players.append(((t, pid), dist))
                
        return sorted(players, key=lambda x: x[1])
        
    def is_position_free(self, x: int, y: int, radius: int = 1) -> bool:
        """
        Проверяет, свободна ли позиция (с учетом радиуса).
        """
        for pos in self.positions.values():
            if self.get_distance((x, y), pos) <= radius:
                return False
        return True
        
    def get_team_average_position(self, team_type: str) -> Tuple[float, float]:
        """
        Вычисляет среднюю позицию команды на поле.
        """
        positions = [(x, y) for (t, _), (x, y) in self.positions.items() if t == team_type]
        if not positions:
            return (0, 0)
            
        avg_x = sum(x for x, _ in positions) / len(positions)
        avg_y = sum(y for _, y in positions) / len(positions)
        return (avg_x, avg_y)

# --- ????? ????? C:\realfootballsim\matches\pitch.py ---


# --- ?????? ????? C:\realfootballsim\matches\player_agent.py ---

import random

class PlayerAgent:
    def __init__(self, player_model):
        # Базовая информация
        self.player_model = player_model
        self.full_name = player_model.full_name
        self.position = player_model.position
        
        # Базовые характеристики
        self.condition = 100  # Физическое состояние
        self.morale = 100    # Моральное состояние
        
    def decide_action(self, match_state):
        """Принятие решения о следующем действии"""
        if self.position in ['Center Forward', 'Attacking Midfielder']:
            return 'attack' if random.random() < 0.7 else 'position'
        elif self.position == 'Midfielder':
            return 'attack' if random.random() < 0.5 else 'position'
        else:
            return 'position'

    def perform_action(self, action, match_state):
        """Выполнение действия"""
        # Простая реализация - возвращаем True/False для успеха/неудачи
        if action == 'attack':
            return random.random() < 0.4
        elif action == 'position':
            return True
        return False

# --- ????? ????? C:\realfootballsim\matches\player_agent.py ---


# --- ?????? ????? C:\realfootballsim\matches\tests.py ---

from django.test import TestCase

# Create your tests here.

# --- ????? ????? C:\realfootballsim\matches\tests.py ---


# --- ?????? ????? C:\realfootballsim\matches\urls.py ---

from django.urls import path
from . import views

app_name = 'matches'

urlpatterns = [
    path('', views.MatchListView.as_view(), name='match_list'),
    path('create/', views.CreateMatchView.as_view(), name='create_match'),
    path('<int:pk>/', views.MatchDetailView.as_view(), name='match_detail'),
    path('<int:match_id>/simulate/', views.simulate_match_view, name='simulate_match'),
]

# --- ????? ????? C:\realfootballsim\matches\urls.py ---


# --- ?????? ????? C:\realfootballsim\matches\views.py ---

from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import CreateView, DetailView, ListView
from django.urls import reverse
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.utils import timezone
from .models import Match, MatchEvent
from clubs.models import Club
from .match_simulation import simulate_match

class CreateMatchView(CreateView):
    model = Match
    fields = ['home_team', 'away_team', 'datetime']  # Исправлено с date на datetime
    template_name = 'matches/create_match.html'

    def form_valid(self, form):
        match = form.save()
        return redirect(reverse('matches:match_detail', kwargs={'pk': match.pk}))

class MatchDetailView(DetailView):
    model = Match
    template_name = 'matches/match_detail.html'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['match_events'] = MatchEvent.objects.filter(match=self.object).order_by('minute')
        return context

@login_required
def simulate_match_view(request, match_id):
    # Если match_id = 0, создаем новый тестовый матч
    if match_id == 0:
        # Получаем клуб пользователя
        club = request.user.club
        # Выбираем случайного бота-соперника
        opponent = Club.objects.filter(is_bot=True).exclude(id=club.id).order_by('?').first()
        if not opponent:
            return render(request, 'matches/no_opponent.html', {'club': club})
        
        # Создаем новый матч
        match = Match.objects.create(
            home_team=club,
            away_team=opponent,
            datetime=timezone.now(),  # Исправлено с date на datetime
            status='scheduled'
        )
        match_id = match.id
    
    # Запускаем симуляцию матча
    simulate_match(match_id)
    
    # Получаем обновленный матч и события
    match = get_object_or_404(Match, id=match_id)
    match_events = MatchEvent.objects.filter(match=match).order_by('minute')
    
    # Отображаем страницу с результатами матча
    return render(request, 'matches/match_detail.html', {
        'match': match,
        'match_events': match_events,
    })

@method_decorator(login_required, name='dispatch')
class MatchListView(ListView):
    model = Match
    template_name = 'matches/match_list.html'
    context_object_name = 'matches'

    def get_queryset(self):
        return Match.objects.filter(home_team=self.request.user.club) | \
               Match.objects.filter(away_team=self.request.user.club)

# --- ????? ????? C:\realfootballsim\matches\views.py ---


# --- ?????? ????? C:\realfootballsim\matches\__init__.py ---


# --- ????? ????? C:\realfootballsim\matches\__init__.py ---


# --- ?????? ????? C:\realfootballsim\players\management\commands\update_player_attributes.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from players.models import Player
from players.utils import generate_player_stats
from tqdm import tqdm

class Command(BaseCommand):
    help = 'Updates existing players with new attributes'

    def add_arguments(self, parser):
        parser.add_argument(
            '--batch-size',
            type=int,
            default=100,
            help='How many players to update in one batch'
        )

    def handle(self, *args, **options):
        batch_size = options['batch_size']
        
        try:
            # Получаем общее количество игроков
            total_players = Player.objects.count()
            self.stdout.write(f"Found {total_players} players to update")

            # Используем tqdm для отображения прогресса
            with tqdm(total=total_players) as pbar:
                # Обрабатываем игроков батчами для экономии памяти
                for i in range(0, total_players, batch_size):
                    with transaction.atomic():
                        players = Player.objects.all()[i:i+batch_size]
                        
                        for player in players:
                            # Генерируем новые характеристики
                            stats = generate_player_stats(
                                player.position,
                                player.player_class
                            )
                            
                            # Обновляем характеристики игрока
                            for attr, value in stats.items():
                                setattr(player, attr, value)
                            
                            player.save()
                            pbar.update(1)
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully updated {total_players} players'
                    )
                )

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(
                    f'Error updating players: {str(e)}'
                )
            )
            raise e

# --- ????? ????? C:\realfootballsim\players\management\commands\update_player_attributes.py ---


# --- ?????? ????? C:\realfootballsim\players\migrations\0001_initial.py ---

# Generated by Django 5.0.1 on 2024-12-07 04:02

import django.db.models.deletion
import django_countries.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('clubs', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Player',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('first_name', models.CharField(default='', max_length=100, verbose_name='First Name')),
                ('last_name', models.CharField(default='', max_length=100, verbose_name='Last Name')),
                ('age', models.PositiveIntegerField(default=17, verbose_name='Age')),
                ('nationality', django_countries.fields.CountryField(default='Unknown', max_length=2, verbose_name='Nationality')),
                ('position', models.CharField(choices=[('Goalkeeper', 'Goalkeeper'), ('Right Back', 'Right Back'), ('Left Back', 'Left Back'), ('Center Back', 'Center Back'), ('Defensive Midfielder', 'Central Defensive Midfielder'), ('Right Midfielder', 'Right Midfielder'), ('Central Midfielder', 'Central Midfielder'), ('Left Midfielder', 'Left Midfielder'), ('Attacking Midfielder', 'Attacking Midfielder'), ('Center Forward', 'Center Forward')], default='Unknown', max_length=50, verbose_name='Position')),
                ('player_class', models.IntegerField(default=1, verbose_name='Player Class')),
                ('strength', models.IntegerField(default=0, verbose_name='Strength')),
                ('stamina', models.IntegerField(default=0, verbose_name='Stamina')),
                ('pace', models.IntegerField(default=0, verbose_name='Pace')),
                ('positioning', models.IntegerField(default=0, verbose_name='Positioning')),
                ('reflexes', models.IntegerField(default=0, verbose_name='Reflexes')),
                ('handling', models.IntegerField(default=0, verbose_name='Handling')),
                ('aerial', models.IntegerField(default=0, verbose_name='Aerial')),
                ('command', models.IntegerField(default=0, verbose_name='Command')),
                ('distribution', models.IntegerField(default=0, verbose_name='Distribution')),
                ('one_on_one', models.IntegerField(default=0, verbose_name='One on One')),
                ('rebound_control', models.IntegerField(default=0, verbose_name='Rebound Control')),
                ('shot_reading', models.IntegerField(default=0, verbose_name='Shot Reading')),
                ('marking', models.IntegerField(default=0, verbose_name='Marking')),
                ('tackling', models.IntegerField(default=0, verbose_name='Tackling')),
                ('work_rate', models.IntegerField(default=0, verbose_name='Work Rate')),
                ('passing', models.IntegerField(default=0, verbose_name='Passing')),
                ('crossing', models.IntegerField(default=0, verbose_name='Crossing')),
                ('dribbling', models.IntegerField(default=0, verbose_name='Dribbling')),
                ('flair', models.IntegerField(default=0, verbose_name='Flair')),
                ('heading', models.IntegerField(default=0, verbose_name='Heading')),
                ('finishing', models.IntegerField(default=0, verbose_name='Finishing')),
                ('long_range', models.IntegerField(default=0, verbose_name='Long Range')),
                ('vision', models.IntegerField(default=0, verbose_name='Vision')),
                ('accuracy', models.IntegerField(default=0, verbose_name='Accuracy')),
                ('club', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='clubs.club', verbose_name='Club')),
            ],
            options={
                'verbose_name': 'Player',
                'verbose_name_plural': 'Players',
                'ordering': ['last_name', 'first_name'],
                'unique_together': {('first_name', 'last_name')},
            },
        ),
    ]

# --- ????? ????? C:\realfootballsim\players\migrations\0001_initial.py ---


# --- ?????? ????? C:\realfootballsim\players\migrations\0002_player_experience.py ---

# Generated by Django 5.0.1 on 2024-12-11 14:56

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('players', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='player',
            name='experience',
            field=models.FloatField(default=0.0, verbose_name='Experience'),
        ),
    ]

# --- ????? ????? C:\realfootballsim\players\migrations\0002_player_experience.py ---


# --- ?????? ????? C:\realfootballsim\players\migrations\__init__.py ---


# --- ????? ????? C:\realfootballsim\players\migrations\__init__.py ---


# --- ?????? ????? C:\realfootballsim\players\templates\players\player_detail.html ---

{% extends 'core/base.html' %}

{% block content %}
<div class="container">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h1 class="h3 mb-0">{{ player.first_name }} {{ player.last_name }}</h1>
                        <span class="badge bg-primary">{{ player.position }}</span>
                    </div>
                </div>
                <div class="card-body">
                    <!-- Player Info -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <h4 class="h5 mb-3">Player Info</h4>
                            <ul class="list-unstyled">
                                <li class="mb-2">
                                    <strong>Club:</strong> 
                                    <a href="{% url 'clubs:club_detail' player.club.id %}" class="text-decoration-none">
                                        {{ player.club.name }}
                                        {% if player.club.is_bot %}<small>(Bot)</small>{% endif %}
                                    </a>
                                </li>
                                <li class="mb-2"><strong>Age:</strong> {{ player.age }}</li>
                                <li class="mb-2"><strong>Nationality:</strong> {{ player.nationality }}</li>
                                {% if player.player_class %}
                                <li class="mb-2">
                                    <strong>Class:</strong> 
                                    <span class="badge bg-info">Class {{ player.player_class }}</span>
                                </li>
                                {% endif %}
                                <!-- Добавляем отображение опыта -->
                                <li class="mb-2">
                                    <strong>Experience:</strong> {{ player.experience|floatformat:1 }}
                                </li>
                                <li class="mb-2">
                                    <strong>Overall Rating:</strong> 
                                    <span class="badge bg-success">{{ player.overall_rating }}</span>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <!-- Attributes -->
                    <div class="row">
                        {% if player.position == 'Goalkeeper' %}
                            <!-- Physical Attributes -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Physical</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Strength:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.strength }}%" aria-valuenow="{{ player.strength }}" aria-valuemin="0" aria-valuemax="100">{{ player.strength }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Stamina:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.stamina }}%" aria-valuenow="{{ player.stamina }}" aria-valuemin="0" aria-valuemax="100">{{ player.stamina }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Pace:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.pace }}%" aria-valuenow="{{ player.pace }}" aria-valuemin="0" aria-valuemax="100">{{ player.pace }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Goalkeeper Core Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Core Goalkeeper Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Reflexes:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.reflexes }}%" aria-valuenow="{{ player.reflexes }}" aria-valuemin="0" aria-valuemax="100">{{ player.reflexes }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Handling:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.handling }}%" aria-valuenow="{{ player.handling }}" aria-valuemin="0" aria-valuemax="100">{{ player.handling }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Positioning:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.positioning }}%" aria-valuenow="{{ player.positioning }}" aria-valuemin="0" aria-valuemax="100">{{ player.positioning }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Aerial:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.aerial }}%" aria-valuenow="{{ player.aerial }}" aria-valuemin="0" aria-valuemax="100">{{ player.aerial }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Additional Goalkeeper Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Additional Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Command:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.command }}%" aria-valuenow="{{ player.command }}" aria-valuemin="0" aria-valuemax="100">{{ player.command }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Distribution:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.distribution }}%" aria-valuenow="{{ player.distribution }}" aria-valuemin="0" aria-valuemax="100">{{ player.distribution }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>One on One:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.one_on_one }}%" aria-valuenow="{{ player.one_on_one }}" aria-valuemin="0" aria-valuemax="100">{{ player.one_on_one }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Shot Reading:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.shot_reading }}%" aria-valuenow="{{ player.shot_reading }}" aria-valuemin="0" aria-valuemax="100">{{ player.shot_reading }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Rebound Control:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.rebound_control }}%" aria-valuenow="{{ player.rebound_control }}" aria-valuemin="0" aria-valuemax="100">{{ player.rebound_control }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        {% else %}
                            <!-- Physical Attributes -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Physical</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Strength:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.strength }}%" aria-valuenow="{{ player.strength }}" aria-valuemin="0" aria-valuemax="100">{{ player.strength }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Stamina:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.stamina }}%" aria-valuenow="{{ player.stamina }}" aria-valuemin="0" aria-valuemax="100">{{ player.stamina }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Pace:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.pace }}%" aria-valuenow="{{ player.pace }}" aria-valuemin="0" aria-valuemax="100">{{ player.pace }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Work Rate:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.work_rate }}%" aria-valuenow="{{ player.work_rate }}" aria-valuemin="0" aria-valuemax="100">{{ player.work_rate }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Technical Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Technical Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Passing:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.passing }}%" aria-valuenow="{{ player.passing }}" aria-valuemin="0" aria-valuemax="100">{{ player.passing }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Dribbling:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.dribbling }}%" aria-valuenow="{{ player.dribbling }}" aria-valuemin="0" aria-valuemax="100">{{ player.dribbling }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Crossing:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.crossing }}%" aria-valuenow="{{ player.crossing }}" aria-valuemin="0" aria-valuemax="100">{{ player.crossing }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Heading:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.heading }}%" aria-valuenow="{{ player.heading }}" aria-valuemin="0" aria-valuemax="100">{{ player.heading }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Finishing:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.finishing }}%" aria-valuenow="{{ player.finishing }}" aria-valuemin="0" aria-valuemax="100">{{ player.finishing }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Mental & Additional Skills -->
                            <div class="col-md-4 mb-3">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Mental & Additional Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="attribute-list">
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Vision:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.vision }}%" aria-valuenow="{{ player.vision }}" aria-valuemin="0" aria-valuemax="100">{{ player.vision }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Flair:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.flair }}%" aria-valuenow="{{ player.flair }}" aria-valuemin="0" aria-valuemax="100">{{ player.flair }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Accuracy:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.accuracy }}%" aria-valuenow="{{ player.accuracy }}" aria-valuemin="0" aria-valuemax="100">{{ player.accuracy }}</div>
                                                </div>
                                            </div>
                                            <div class="d-flex justify-content-between mb-2">
                                                <span>Long Range:</span>
                                                <div class="progress w-50">
                                                    <div class="progress-bar" role="progressbar" style="width: {{ player.long_range }}%" aria-valuenow="{{ player.long_range }}" aria-valuemin="0" aria-valuemax="100">{{ player.long_range }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Defense Skills -->
                            <div class="col-md-12 mb-3">
                                <div class="card">
                                    <div class="card-header">
                                        <h5 class="card-title h6 mb-0">Defense Skills</h5>
                                    </div>
                                    <div class="card-body">
                                        <div class="row">
                                            <div class="col-md-4">
                                                <div class="d-flex justify-content-between mb-2">
                                                    <span>Marking:</span>
                                                    <div class="progress w-50">
                                                        <div class="progress-bar" role="progressbar" style="width: {{ player.marking }}%" aria-valuenow="{{ player.marking }}" aria-valuemin="0" aria-valuemax="100">{{ player.marking }}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="col-md-4">
                                                <div class="d-flex justify-content-between mb-2">
                                                    <span>Tackling:</span>
                                                    <div class="progress w-50">
                                                        <div class="progress-bar" role="progressbar" style="width: {{ player.tackling }}%" aria-valuenow="{{ player.tackling }}" aria-valuemin="0" aria-valuemax="100">{{ player.tackling }}</div>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="col-md-4">
                                                <div class="d-flex justify-content-between mb-2">
                                                    <span>Positioning:</span>
                                                    <div class="progress w-50">
                                                        <div class="progress-bar" role="progressbar" style="width: {{ player.positioning }}%" aria-valuenow="{{ player.positioning }}" aria-valuemin="0" aria-valuemax="100">{{ player.positioning }}</div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\players\templates\players\player_detail.html ---


# --- ?????? ????? C:\realfootballsim\players\admin.py ---

from django.contrib import admin
from .models import Player

@admin.register(Player)
class PlayerAdmin(admin.ModelAdmin):
    list_display = ('last_name', 'first_name', 'club', 'nationality')
    list_filter = ('club', 'nationality')
    search_fields = ('last_name', 'first_name', 'club__name', 'nationality')

# или можно использовать
# admin.site.register(Player, PlayerAdmin)

# --- ????? ????? C:\realfootballsim\players\admin.py ---


# --- ?????? ????? C:\realfootballsim\players\apps.py ---

from django.apps import AppConfig


class PlayersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'players'

# --- ????? ????? C:\realfootballsim\players\apps.py ---


# --- ?????? ????? C:\realfootballsim\players\models.py ---

from django.db import models
from django_countries.fields import CountryField

class Player(models.Model):
    POSITIONS = [
        ('Goalkeeper', 'Goalkeeper'),
        ('Right Back', 'Right Back'), 
        ('Left Back', 'Left Back'),
        ('Center Back', 'Center Back'),
        ('Defensive Midfielder', 'Central Defensive Midfielder'),
        ('Right Midfielder', 'Right Midfielder'),
        ('Central Midfielder', 'Central Midfielder'),
        ('Left Midfielder', 'Left Midfielder'),
        ('Attacking Midfielder', 'Attacking Midfielder'),
        ('Center Forward', 'Center Forward'),
    ]

    # Базовая информация
    first_name = models.CharField(max_length=100, default='', verbose_name="First Name")
    last_name = models.CharField(max_length=100, default='', verbose_name="Last Name")
    age = models.PositiveIntegerField(default=17, verbose_name="Age")
    club = models.ForeignKey('clubs.Club', on_delete=models.CASCADE, verbose_name="Club", null=True, blank=True)
    nationality = CountryField(blank_label='(select country)', verbose_name="Nationality", default="Unknown")
    position = models.CharField(max_length=50, choices=POSITIONS, default='Unknown', verbose_name="Position")
    player_class = models.IntegerField(default=1, verbose_name="Player Class")

    # Общие характеристики
    strength = models.IntegerField(default=0, verbose_name="Strength")
    stamina = models.IntegerField(default=0, verbose_name="Stamina")
    pace = models.IntegerField(default=0, verbose_name="Pace")
    positioning = models.IntegerField(default=0, verbose_name="Positioning")

    # Характеристики для вратарей
    reflexes = models.IntegerField(default=0, verbose_name="Reflexes")
    handling = models.IntegerField(default=0, verbose_name="Handling")
    aerial = models.IntegerField(default=0, verbose_name="Aerial")
    command = models.IntegerField(default=0, verbose_name="Command")
    distribution = models.IntegerField(default=0, verbose_name="Distribution")
    one_on_one = models.IntegerField(default=0, verbose_name="One on One")
    rebound_control = models.IntegerField(default=0, verbose_name="Rebound Control")
    shot_reading = models.IntegerField(default=0, verbose_name="Shot Reading")

    # Характеристики для полевых игроков
    marking = models.IntegerField(default=0, verbose_name="Marking")
    tackling = models.IntegerField(default=0, verbose_name="Tackling")
    work_rate = models.IntegerField(default=0, verbose_name="Work Rate")
    passing = models.IntegerField(default=0, verbose_name="Passing")
    crossing = models.IntegerField(default=0, verbose_name="Crossing")
    dribbling = models.IntegerField(default=0, verbose_name="Dribbling")
    flair = models.IntegerField(default=0, verbose_name="Flair")
    heading = models.IntegerField(default=0, verbose_name="Heading")
    finishing = models.IntegerField(default=0, verbose_name="Finishing")
    long_range = models.IntegerField(default=0, verbose_name="Long Range")
    vision = models.IntegerField(default=0, verbose_name="Vision")
    accuracy = models.IntegerField(default=0, verbose_name="Accuracy")

    # Новое поле опыта
    experience = models.FloatField(default=0.0, verbose_name="Experience")

    class Meta:
        unique_together = ('first_name', 'last_name')
        verbose_name = 'Player'
        verbose_name_plural = 'Players'
        ordering = ['last_name', 'first_name']

    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.club.name if self.club else 'No Club'}) - {self.position}"

    def save(self, *args, **kwargs):
        if not self.nationality and self.club:
            self.nationality = self.club.country
        super().save(*args, **kwargs)

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    @property
    def is_goalkeeper(self):
        return self.position == 'Goalkeeper'

    @property
    def overall_rating(self):
        """Вычисляет общий рейтинг игрока на основе его характеристик,
        учитывая опыт. Допустим, за каждый 1.0 опыта характеристики растут на 1%."""

        # Коэффициент влияния опыта (1% за единицу опыта)
        experience_multiplier = 1 + self.experience * 0.01

        if self.is_goalkeeper:
            attributes = [
                self.reflexes, self.handling, self.aerial,
                self.command, self.distribution, self.one_on_one,
                self.rebound_control, self.shot_reading,
                self.strength, self.stamina, self.pace, self.positioning
            ]
        else:
            attributes = [
                self.strength, self.stamina, self.pace,
                self.marking, self.tackling, self.work_rate,
                self.positioning, self.passing, self.crossing,
                self.dribbling, self.flair, self.heading,
                self.finishing, self.long_range, self.vision,
                self.accuracy
            ]

        # Применяем опытный множитель к каждой характеристике
        adjusted_attributes = [int(attr * experience_multiplier) for attr in attributes]

        return sum(adjusted_attributes) // len(adjusted_attributes)

    def get_position_specific_attributes(self):
        """Возвращает атрибуты, специфичные для позиции игрока"""
        if self.is_goalkeeper:
            return {
                'reflexes': self.reflexes,
                'handling': self.handling,
                'aerial': self.aerial,
                'command': self.command,
                'distribution': self.distribution,
                'one_on_one': self.one_on_one,
                'rebound_control': self.rebound_control,
                'shot_reading': self.shot_reading
            }
        else:
            return {
                'marking': self.marking,
                'tackling': self.tackling,
                'work_rate': self.work_rate,
                'passing': self.passing,
                'crossing': self.crossing,
                'dribbling': self.dribbling,
                'flair': self.flair,
                'heading': self.heading,
                'finishing': self.finishing,
                'long_range': self.long_range,
                'vision': self.vision,
                'accuracy': self.accuracy
            }

# --- ????? ????? C:\realfootballsim\players\models.py ---


# --- ?????? ????? C:\realfootballsim\players\player_attributes_config.py ---

# player_attributes_config.py

CLASS_1_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes': [(1.0, 0.40), (1.0, 0.35), (1.0, 0.25)],
            'handling': [(1.0, 0.40), (1.0, 0.35), (1.0, 0.25)],
            'positioning': [(1.0, 0.40), (1.0, 0.35), (1.0, 0.25)],
            'aerial': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'jumping': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'command': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'throwing': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'kicking': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'strength': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'stamina': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
            'pace': [(1.0, 0.50), (1.0, 0.30), (1.0, 0.20)],
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

CLASS_2_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes': [(3.3, 0.40), (2.3, 0.35), (1.3, 0.25)],
            'handling': [(3.2, 0.40), (2.2, 0.35), (1.2, 0.25)],
            'positioning': [(3.1, 0.40), (2.1, 0.35), (1.1, 0.25)],
            'aerial': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'jumping': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'command': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'throwing': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'kicking': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)]
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

CLASS_3_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes':  [(3.7, 0.40), (3.7, 0.35), (0.7, 0.25)],
            'handling':  [(3.7, 0.40), (3.7, 0.35), (0.7, 0.25)],
            'positioning':  [(3.7, 0.40), (3.7, 0.35), (0.7, 0.25)],
            'aerial': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'jumping': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'command': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'throwing': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'kicking': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)]
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

CLASS_4_WEIGHTS = {
    'Goalkeeper': {
        'attributes': {
            'reflexes': [(0.7, 0.40), (0.7, 0.35), (0.7, 0.25)],
            'handling':  [(0.7, 0.40), (0.7, 0.35), (0.7, 0.25)],
            'positioning':  [(0.7, 0.40), (0.7, 0.35), (0.7, 0.25)],
            'aerial': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'jumping': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'command': [(2.0, 0.50), (1.5, 0.30), (1.0, 0.20)],
            'throwing': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'kicking': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (0.5, 0.20)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)]
        }
    },
    'Right Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Left Back': {
        'attributes': {
            'tackling': [(2.3, 0.40), (1.3, 0.35), (3.3, 0.25)],
            'marking': [(2.2, 0.40), (1.2, 0.35), (3.2, 0.25)],
            'crossing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'passing': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Center Back': {
        'attributes': {
            'marking': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'tackling': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'heading': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'stamina': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'ball_control': [(1.0, 1.0)],
            'crossing': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)],
            'vision': [(1.0, 1.0)]
        }
    },
    'Defensive Midfielder': {
        'attributes': {
            'tackling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'marking': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'passing': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'strength': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'work_rate': [(2.5, 0.50), (2.0, 0.30), (3.0, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'ball_control': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'heading': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'dribbling': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Central Midfielder': {
        'attributes': {
            'passing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'work_rate': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'positioning': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'strength': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'pace': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'tackling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'marking': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'dribbling': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'long_range': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'crossing': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)]
        }
    },
    'Right Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Left Midfielder': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
    'Attacking Midfielder': {
        'attributes': {
            'dribbling': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'vision': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'ball_control': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'finishing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'long_range': [(2.0, 0.50)],
            'strength': [(1.0, 1.0)],
            'stamina': [(1.0, 1.0)],
            'pace': [(1.0, 1.0)],
            'work_rate': [(1.0, 1.0)],
            'positioning': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)]
        }
    },
    'Center Forward': {
        'attributes': {
            'crossing': [(3.3, 0.40), (2.3, 0.35), (2.3, 0.25)],
            'pace': [(2.2, 0.40), (3.2, 0.35), (2.2, 0.25)],
            'dribbling': [(2.1, 0.40), (3.1, 0.35), (1.1, 0.25)],
            'stamina': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'ball_control': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'passing': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'work_rate': [(2.0, 0.50), (1.5, 0.30), (2.5, 0.20)],
            'vision': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'positioning': [(1.5, 0.50), (1.0, 0.30), (2.0, 0.20)],
            'strength': [(1.0, 1.0)],
            'marking': [(1.0, 1.0)],
            'tackling': [(1.0, 1.0)],
            'heading': [(1.0, 1.0)],
            'finishing': [(1.0, 1.0)],
            'long_range': [(1.0, 1.0)]
        }
    },
}

POSITIONS_WEIGHTS = {
    1: CLASS_1_WEIGHTS,
    2: CLASS_2_WEIGHTS,
    3: CLASS_3_WEIGHTS,
    4: CLASS_4_WEIGHTS
}

# --- ????? ????? C:\realfootballsim\players\player_attributes_config.py ---


# --- ?????? ????? C:\realfootballsim\players\tests.py ---

# players/tests.py
from django.test import TestCase, Client
from django.urls import reverse
from accounts.models import CustomUser  # Импортируем пользовательскую модель
from clubs.models import Club
from players.models import Player

class PlayerTests(TestCase):
    def setUp(self):
        # Создаем тестового пользователя с использованием CustomUser
        self.user = CustomUser.objects.create_user(username='testuser', email='testuser@example.com', password='password123')

        # Создаем тестовый клуб и назначаем пользователя владельцем
        self.club = Club.objects.create(name='Test Club', country='Test Country', owner=self.user)

        # Создаем клиента для тестирования запросов
        self.client = Client()
        self.client.login(username='testuser', password='password123')

        # URL для создания игрока
        self.create_player_url = reverse('create_player', kwargs={'pk': self.club.pk})

    def test_generate_player(self):
        """Тест генерации нового игрока"""
        response = self.client.get(self.create_player_url, {'position': 'Midfielder'})

        # Проверяем перенаправление на страницу игрока
        self.assertEqual(response.status_code, 302)
        player = Player.objects.first()
        self.assertIsNotNone(player)
        self.assertEqual(player.position, 'Midfielder')
        self.assertEqual(player.club, self.club)

    def test_player_detail_page(self):
        """Тест страницы деталей игрока, включая отображение характеристик"""
        player = Player.objects.create(
            club=self.club,
            first_name='Test',
            last_name='Player',
            nationality='Test Country',
            age=18,
            position='Midfielder',
            strength=80,
            stamina=75,
            pace=70
        )
        detail_url = reverse('players:player_detail', args=[player.pk])
        response = self.client.get(detail_url)

        # Проверяем корректность отображения страницы деталей игрока
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, player.first_name)
        self.assertContains(response, player.last_name)
        self.assertContains(response, 'Strength: 80')
        self.assertContains(response, 'Stamina: 75')
        self.assertContains(response, 'Pace: 70')

# --- ????? ????? C:\realfootballsim\players\tests.py ---


# --- ?????? ????? C:\realfootballsim\players\urls.py ---

from django.urls import path
from .views import PlayerDetailView

urlpatterns = [
    path('detail/<int:pk>/', PlayerDetailView.as_view(), name='player_detail'),
]

# --- ????? ????? C:\realfootballsim\players\urls.py ---


# --- ?????? ????? C:\realfootballsim\players\utils.py ---

from scipy.stats import norm
import random
import sys
import os

def generate_stat(weight=1):
    """Генерирует базовую характеристику"""
    base_value = norm.rvs(50, 10)
    weighted_value = base_value * weight
    return max(1, min(99, int(weighted_value)))

def generate_player_stats(position, player_class):
    """Генерирует характеристики игрока в зависимости от позиции"""
    # Базовые характеристики
    base_stats = {
        'strength': generate_stat(),
        'stamina': generate_stat(),
        'pace': generate_stat(),
        'positioning': generate_stat(),
    }

    if position == 'Goalkeeper':
        # Характеристики вратаря (12 характеристик)
        gk_stats = {
            'reflexes': generate_stat(),
            'handling': generate_stat(),
            'aerial': generate_stat(),
            'command': generate_stat(),
            'distribution': generate_stat(),
            'one_on_one': generate_stat(),
            'rebound_control': generate_stat(),
            'shot_reading': generate_stat()
        }
        stats = {**base_stats, **gk_stats}
    else:
        # Характеристики полевого игрока (16 характеристик)
        field_stats = {
            'marking': generate_stat(),
            'tackling': generate_stat(),
            'work_rate': generate_stat(),
            'passing': generate_stat(),
            'crossing': generate_stat(),
            'dribbling': generate_stat(),
            'flair': generate_stat(),
            'heading': generate_stat(),
            'finishing': generate_stat(),
            'long_range': generate_stat(),
            'vision': generate_stat(),
            'accuracy': generate_stat()
        }
        stats = {**base_stats, **field_stats}

        # Модификаторы позиций
        position_modifiers = {
            'Center Back': {
                'marking': 1.2, 'tackling': 1.2, 'heading': 1.1,
                'strength': 1.1, 'finishing': 0.8, 'dribbling': 0.8
            },
            'Right Back': {
                'pace': 1.1, 'crossing': 1.1, 'stamina': 1.1,
                'tackling': 1.1, 'marking': 1.1
            },
            'Left Back': {
                'pace': 1.1, 'crossing': 1.1, 'stamina': 1.1,
                'tackling': 1.1, 'marking': 1.1
            },
            'Defensive Midfielder': {
                'tackling': 1.2, 'marking': 1.1, 'passing': 1.1,
                'work_rate': 1.2, 'vision': 1.1
            },
            'Central Midfielder': {
                'passing': 1.2, 'vision': 1.2, 'work_rate': 1.1,
                'stamina': 1.1, 'positioning': 1.1
            },
            'Attacking Midfielder': {
                'vision': 1.2, 'passing': 1.2, 'dribbling': 1.1,
                'flair': 1.2, 'finishing': 1.1
            },
            'Center Forward': {
                'finishing': 1.3, 'heading': 1.2, 'positioning': 1.2,
                'strength': 1.1, 'dribbling': 1.1
            }
        }

        # Применяем модификаторы позиции
        if position in position_modifiers:
            for attr, mod in position_modifiers[position].items():
                if attr in stats:
                    stats[attr] = min(99, int(stats[attr] * mod))

    # Модификатор класса игрока
    class_modifier = (5 - player_class) * 0.1  # +10% за каждый класс выше 1
    for key in stats:
        stats[key] = min(99, int(stats[key] * (1 + class_modifier)))

    return stats

def print_player_stats(stats):
    """Вспомогательная функция для вывода характеристик"""
    print("\nХарактеристики игрока:")
    total = 0
    count = 0
    for attr, value in sorted(stats.items()):
        print(f"{attr}: {value}")
        total += value
        count += 1
    if count > 0:
        print(f"\nСредний рейтинг: {total/count:.1f}")

# --- ????? ????? C:\realfootballsim\players\utils.py ---


# --- ?????? ????? C:\realfootballsim\players\views.py ---

from django.views.generic import DetailView
from .models import Player

class PlayerDetailView(DetailView):
    model = Player
    template_name = 'players/player_detail.html'

# --- ????? ????? C:\realfootballsim\players\views.py ---


# --- ?????? ????? C:\realfootballsim\players\__init__.py ---


# --- ????? ????? C:\realfootballsim\players\__init__.py ---


# --- ?????? ????? C:\realfootballsim\realfootballsim\asgi.py ---

"""
ASGI config for realfootballsim project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')

application = get_asgi_application()

# --- ????? ????? C:\realfootballsim\realfootballsim\asgi.py ---


# --- ?????? ????? C:\realfootballsim\realfootballsim\celery.py ---

import os
from celery import Celery
from celery.schedules import crontab

# Устанавливаем переменную окружения для настроек Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')

app = Celery('realfootballsim')

# Загружаем настройки из settings.py
app.config_from_object('django.conf:settings', namespace='CELERY')

# Настраиваем периодические задачи
app.conf.beat_schedule = {
    # Симуляция матчей (каждую минуту)
    'simulate-matches': {
        'task': 'tournaments.check_and_simulate_matches',
        'schedule': crontab(),  # каждую минуту
    },
    # Проверка окончания сезона (каждый день в полночь)
    'check-season-end': {
        'task': 'tournaments.check_season_end',
        'schedule': crontab(minute=0, hour=0),  # в 00:00
    }
}

# Автоматически обнаруживаем и регистрируем задачи из всех приложений Django
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')

# --- ????? ????? C:\realfootballsim\realfootballsim\celery.py ---


# --- ?????? ????? C:\realfootballsim\realfootballsim\settings.py ---

from pathlib import Path
import os
from celery.schedules import crontab

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = 'django-insecure-0p3aqax2r2xolyvtfda6q_aa@q1l6n!w4$8sjo1ed&*)h*2l37'

DEBUG = True

ALLOWED_HOSTS = []

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',
    'core',
    'players',
    'clubs',
    'matches',
    'tournaments.apps.TournamentsConfig',
    'django_celery_beat',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'tournaments.timezone_middleware.TimezoneMiddleware',
]

ROOT_URLCONF = 'realfootballsim.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'tournaments.context_processors.timezone_context',
            ],
        },
    },
]

WSGI_APPLICATION = 'realfootballsim.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
        'OPTIONS': {
            'timeout': 60,  # Увеличиваем таймаут до 60 секунд
            'isolation_level': 'IMMEDIATE'  # Уровень изоляции
        },
        'ATOMIC_REQUESTS': False,  # Отключаем автоматические транзакции
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

AUTH_USER_MODEL = 'accounts.CustomUser'

LOGIN_REDIRECT_URL = 'clubs:club_detail'
LOGIN_URL = 'accounts:login'
LOGOUT_REDIRECT_URL = 'accounts:login'

# Настройки Celery с увеличенным временем ожидания
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = 'UTC'
CELERY_BROKER_CONNECTION_RETRY_ON_STARTUP = True
CELERY_TASK_TIME_LIMIT = 300  # 5 минут на выполнение задачи
CELERY_TASK_SOFT_TIME_LIMIT = 240  # Мягкий лимит в 4 минуты

# Добавляем настройки для пула воркеров
CELERY_WORKER_MAX_TASKS_PER_CHILD = 50
CELERY_WORKER_PREFETCH_MULTIPLIER = 1

# Настройки периодических задач
CELERY_BEAT_SCHEDULE = {
    'check-matches': {
        'task': 'tournaments.check_and_simulate_matches',
        'schedule': crontab(minute='*'),  # Каждую минуту
    },
    'check-season-end': {
        'task': 'tournaments.check_season_end',
        'schedule': crontab(hour=0, minute=0),  # Каждый день в полночь
    },
}

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': 'debug.log',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'clubs': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'matches': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'tournaments': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}

TOURNAMENT_TIMEZONES = [
    ('UTC', 'UTC'),
    ('Europe/London', 'London'),
    ('Europe/Moscow', 'Moscow'),
    ('America/New_York', 'New York'),
    ('Asia/Tokyo', 'Tokyo'),
]

# --- ????? ????? C:\realfootballsim\realfootballsim\settings.py ---


# --- ?????? ????? C:\realfootballsim\realfootballsim\urls.py ---

from django.contrib import admin
from django.urls import path, include
from core.views import home

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', home, name='home'),
    path('accounts/', include(('accounts.urls', 'accounts'), namespace='accounts')),  # Исправлено
    path('core/', include('core.urls')),
    path('players/', include(('players.urls', 'players'), namespace='players')),
    path('clubs/', include(('clubs.urls', 'clubs'), namespace='clubs')),
    path('matches/', include(('matches.urls', 'matches'), namespace='matches')),
    path('tournaments/', include(('tournaments.urls', 'tournaments'), namespace='tournaments')),
]

# --- ????? ????? C:\realfootballsim\realfootballsim\urls.py ---


# --- ?????? ????? C:\realfootballsim\realfootballsim\wsgi.py ---

"""
WSGI config for realfootballsim project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'realfootballsim.settings')

application = get_wsgi_application()

# --- ????? ????? C:\realfootballsim\realfootballsim\wsgi.py ---


# --- ?????? ????? C:\realfootballsim\realfootballsim\__init__.py ---

from .celery import app as celery_app

__all__ = ('celery_app',)

# --- ????? ????? C:\realfootballsim\realfootballsim\__init__.py ---

# tournaments/management/commands/check_matches.py
from django.core.management.base import BaseCommand
from django.utils import timezone
from matches.models import Match
from matches.match_simulation import simulate_match
import logging
from datetime import datetime

logger = logging.getLogger('matches')

class Command(BaseCommand):
    help = 'Checks and simulates matches that should start now'

    def add_arguments(self, parser):
        # Добавляем опциональный аргумент для тестирования
        parser.add_argument(
            '--debug',
            action='store_true',
            help='Print additional debug information',
        )

    def handle(self, *args, **options):
        now = timezone.now()
        debug = options['debug']

        if debug:
            self.stdout.write(f'Current time: {now}')
            logger.info(f'Starting match check at {now}')

        # Находим матчи, которые должны были начаться
        matches = Match.objects.filter(
            status='scheduled',
            date__lte=now
        ).select_related('home_team', 'away_team')

        if debug:
            self.stdout.write(f'Found {matches.count()} matches to simulate')
            for match in matches:
                self.stdout.write(
                    f'- {match.date}: {match.home_team} vs {match.away_team}'
                )

        if matches.exists():
            logger.info(f'Found {matches.count()} matches to simulate')
            
            for match in matches:
                try:
                    msg = f'Simulating match: {match.home_team} vs {match.away_team} (scheduled for {match.date})'
                    self.stdout.write(msg)
                    logger.info(msg)
                    
                    simulate_match(match.id)
                    
                    logger.info(
                        f'Match completed: {match.home_team} {match.home_score} - {match.away_score} {match.away_team}'
                    )
                except Exception as e:
                    error_msg = f'Error simulating match {match.id}: {str(e)}'
                    self.stdout.write(self.style.ERROR(error_msg))
                    logger.error(error_msg)

            self.stdout.write(
                self.style.SUCCESS(f'Successfully simulated {matches.count()} matches')
            )
        else:
            if debug:
                self.stdout.write('No matches to simulate')

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\check_matches.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\create_new_season.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from tournaments.models import Championship, Season, League
from tournaments.utils import create_championship_matches
from datetime import timedelta

class Command(BaseCommand):
    help = 'Creates new season with championships based on current league assignments'

    def add_arguments(self, parser):
        parser.add_argument(
            '--days',
            type=int,
            default=30,
            help='Duration of the season in days'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Находим последний сезон для определения номера нового
                last_season = Season.objects.order_by('-number').first()
                new_season_number = 1 if not last_season else last_season.number + 1
                
                # Определяем даты сезона
                start_date = timezone.now().date()
                duration = timedelta(days=options['days'])
                end_date = start_date + duration

                # Создаем новый сезон
                new_season = Season.objects.create(
                    number=new_season_number,
                    name=f"Season {new_season_number}",
                    start_date=start_date,
                    end_date=end_date,
                    is_active=True
                )
                
                self.stdout.write(f"Created new season: {new_season}")

                # Получаем все лиги
                leagues = League.objects.all().order_by('country', 'level')
                
                championships_created = 0
                matches_created = 0

                # Создаем чемпионаты для каждой лиги
                for league in leagues:
                    # Проверяем количество команд в лиге
                    teams_in_league = league.clubs.count()
                    if teams_in_league != 16:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Skipping {league}: has {teams_in_league} teams instead of 16"
                            )
                        )
                        continue

                    # Создаем чемпионат
                    championship = Championship.objects.create(
                        season=new_season,
                        league=league,
                        status='pending',
                        start_date=start_date,
                        end_date=end_date
                    )

                    # Добавляем команды в чемпионат
                    for team in league.clubs.all():
                        championship.teams.add(team)

                    # Генерируем расписание матчей
                    create_championship_matches(championship)
                    
                    championships_created += 1
                    matches_created += championship.championshipmatch_set.count()

                    self.stdout.write(
                        f"Created championship for {league.name} with "
                        f"{championship.teams.count()} teams"
                    )

                self.stdout.write(
                    self.style.SUCCESS(
                        f"Successfully created new season {new_season_number} with "
                        f"{championships_created} championships and "
                        f"{matches_created} matches"
                    )
                )

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error creating new season: {str(e)}")
            )
            raise

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\create_new_season.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\create_second_divisions.py ---

# tournaments/management/commands/create_second_divisions.py
from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League
from django_countries import countries

class Command(BaseCommand):
    help = 'Creates second divisions for all countries'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                top_leagues = League.objects.filter(level=1)
                
                for league in top_leagues:
                    # Проверяем, нет ли уже второго дивизиона
                    second_div_exists = League.objects.filter(
                        country=league.country,
                        level=2
                    ).exists()
                    
                    if not second_div_exists:
                        League.objects.create(
                            name=f"{league.country.name} Second Division",
                            country=league.country,
                            level=2,
                            max_teams=16,
                            foreign_players_limit=5
                        )
                        self.stdout.write(
                            self.style.SUCCESS(
                                f"Created second division for {league.country.name}"
                            )
                        )
                
                self.stdout.write(self.style.SUCCESS("All second divisions created!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error creating second divisions: {str(e)}")
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\create_second_divisions.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\create_second_division_championships.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League, Championship, Season
from django.utils import timezone

class Command(BaseCommand):
    help = 'Creates championships for second divisions in current season'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем текущий активный сезон
                current_season = Season.objects.get(is_active=True)
                
                # Получаем все вторые дивизионы
                second_divisions = League.objects.filter(level=2)
                
                championships_created = 0
                for league in second_divisions:
                    # Проверяем, нет ли уже чемпионата для этой лиги в текущем сезоне
                    exists = Championship.objects.filter(
                        season=current_season,
                        league=league
                    ).exists()
                    
                    if not exists:
                        # Создаем чемпионат
                        championship = Championship.objects.create(
                            season=current_season,
                            league=league,
                            status='in_progress',
                            start_date=current_season.start_date,
                            end_date=current_season.end_date,
                            match_time=timezone.now().time().replace(hour=18, minute=0)
                        )
                        
                        # Добавляем все команды лиги в чемпионат
                        for club in league.clubs.all():
                            championship.teams.add(club)
                            
                        championships_created += 1
                        self.stdout.write(f"Created championship for {league.name}")
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully created {championships_created} championships'
                    )
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error creating championships: {str(e)}')
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\create_second_division_championships.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\end_season.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from tournaments.models import Season, Championship
from django.core.management import call_command
from django.db.models import Count, Q

class Command(BaseCommand):
    help = 'Handles the end of season process'

    def add_arguments(self, parser):
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force end season even if not all matches are finished'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем текущий активный сезон
                current_season = Season.objects.get(is_active=True)
                
                # Проверяем завершение всех матчей
                championships = Championship.objects.filter(season=current_season)
                
                unfinished_matches = 0
                for championship in championships:
                    unfinished = championship.championshipmatch_set.filter(
                        ~Q(match__status='finished')
                    ).count()
                    unfinished_matches += unfinished
                
                if unfinished_matches > 0 and not options['force']:
                    self.stdout.write(
                        self.style.WARNING(
                            f"Cannot end season: {unfinished_matches} matches not finished. "
                            "Use --force to override."
                        )
                    )
                    return
                
                # Проверяем все чемпионаты на правильное количество команд
                invalid_championships = []
                for championship in championships:
                    team_count = championship.teams.count()
                    if team_count != 16:
                        invalid_championships.append(
                            f"{championship}: {team_count} teams"
                        )
                
                if invalid_championships and not options['force']:
                    self.stdout.write(
                        self.style.WARNING(
                            "Invalid team counts in championships:\n" + 
                            "\n".join(invalid_championships) +
                            "\nUse --force to override."
                        )
                    )
                    return

                # Завершаем текущий сезон
                self.stdout.write("Processing end of season transitions...")
                
                # Обрабатываем переходы между дивизионами
                call_command('handle_season_transitions')
                
                # Деактивируем текущий сезон
                current_season.is_active = False
                current_season.save()
                
                # Создаем новый сезон
                self.stdout.write("Creating new season...")
                call_command('create_new_season')
                
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Successfully ended season {current_season.number}"
                    )
                )

        except Season.DoesNotExist:
            self.stdout.write(
                self.style.ERROR("No active season found")
            )
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error ending season: {str(e)}")
            )
            raise

    def validate_championship_results(self, championship):
        """
        Проверяет корректность результатов чемпионата
        """
        # Проверяем количество сыгранных матчей для каждой команды
        team_stats = championship.championshipteam_set.all()
        total_teams = team_stats.count()
        expected_matches = (total_teams - 1) * 2  # Каждая команда играет со всеми дважды
        
        for stats in team_stats:
            if stats.matches_played != expected_matches:
                return False, f"Team {stats.team.name} played {stats.matches_played} matches instead of {expected_matches}"
        
        return True, None

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\end_season.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\generate_all_matches.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import Championship
from tournaments.utils import create_championship_matches
import logging

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Generates matches for all divisions'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем все активные чемпионаты
                championships = Championship.objects.filter(
                    status='in_progress'
                ).select_related('league')
                
                total_matches = 0
                for championship in championships:
                    self.stdout.write(
                        f"Generating matches for {championship} "
                        f"(Division {championship.league.level})"
                    )
                    create_championship_matches(championship)
                    matches_count = championship.championshipmatch_set.count()
                    total_matches += matches_count
                    self.stdout.write(
                        f"Created {matches_count} matches for "
                        f"{championship.league.name} (Division {championship.league.level})"
                    )
                    
                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully generated {total_matches} matches '
                        f'for {championships.count()} championships'
                    )
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error generating matches: {str(e)}')
            )
            logger.error(f"Error generating matches: {str(e)}")

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\generate_all_matches.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\generate_championships.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from django_countries import countries
from faker import Faker
from tournaments.models import League, Championship, Season
from clubs.models import Club
from tqdm import tqdm
import sys
import random  # Добавляем импорт random

class Command(BaseCommand):
    help = 'Generates championships for all countries with bot teams'

    def __init__(self):
        super().__init__()
        self.fake = Faker()
        self.team_adjectives = [
            'Red', 'Blue', 'Golden', 'Silver', 'Black', 'White', 'Royal',
            'Imperial', 'Northern', 'United', 'Real', 'Crystal', 'Athletic',
            'Sporting', 'Racing', 'Phoenix', 'Elite', 'Supreme', 'Ancient',
            'Mighty', 'Green', 'Purple', 'Bronze', 'Iron', 'Steel', 
            'Eastern', 'Western', 'Southern', 'Central', 'Inter',
            'Dynamic', 'Olympic', 'Spartak', 'Victoria', 'Glory',
            'Freedom', 'Unity', 'Progressive', 'Classic', 'Modern'
        ]
        self.team_nouns = [
            'Lions', 'Eagles', 'Dragons', 'Warriors', 'Knights', 'Rovers',
            'Rangers', 'Wanderers', 'Stars', 'Kings', 'Legends', 'Phoenix',
            'Tigers', 'Panthers', 'Wolves', 'Falcons', 'Titans', 'Giants',
            'Heroes', 'Guardians', 'Hawks', 'Bears', 'Sharks', 'Vipers',
            'Scorpions', 'Pythons', 'Cobras', 'Stallions', 'Bulls', 'Raiders',
            'Hunters', 'Hornets', 'Ravens', 'Demons', 'Angels', 'Thunder',
            'Lightning', 'Storm', 'United', 'City'
        ]
        self.team_suffixes = ['FC', 'United', 'City', 'Athletic', 'Sporting']
        self.stats = {
            'leagues_created': 0,
            'championships_created': 0,
            'teams_created': 0,
            'countries_processed': 0
        }

    def generate_team_name(self):
        """Generates a unique random team name with more variations"""
        attempts = 0
        max_attempts = 100
        while attempts < max_attempts:
            # 70% chance of standard name (Adjective + Noun)
            # 30% chance of name with suffix (Adjective + Noun + Suffix)
            if random.random() < 0.7:
                adj = self.fake.random_element(self.team_adjectives)
                noun = self.fake.random_element(self.team_nouns)
                name = f"{adj} {noun}"
            else:
                adj = self.fake.random_element(self.team_adjectives)
                noun = self.fake.random_element(self.team_nouns)
                suffix = self.fake.random_element(self.team_suffixes)
                name = f"{adj} {noun} {suffix}"

            if not Club.objects.filter(name=name).exists():
                return name
            attempts += 1
        raise Exception(f"Could not generate unique team name after {max_attempts} attempts")

    def add_arguments(self, parser):
        parser.add_argument(
            '--start-from',
            type=str,
            help='Start from specific country code (e.g., "FR" for France)',
        )
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force recreation of championships even if they exist',
        )

    def handle(self, *args, **options):
        self.stdout.write('Starting championship generation process...')
        
        # Безопасная обработка start_from
        start_from = (options.get('start_from') or '').upper()
        force = options.get('force', False)

        # Предварительная проверка
        existing_leagues = League.objects.count()
        existing_championships = Championship.objects.count()
        existing_clubs = Club.objects.count()

        self.stdout.write(f'Current state:')
        self.stdout.write(f'- Existing leagues: {existing_leagues}')
        self.stdout.write(f'- Existing championships: {existing_championships}')
        self.stdout.write(f'- Existing clubs: {existing_clubs}')
        
        try:
            with transaction.atomic():
                # Create active season if not exists
                season, created = Season.objects.get_or_create(
                    name="2024/2025",
                    defaults={
                        'start_date': '2024-08-01',
                        'end_date': '2025-05-31',
                        'is_active': True
                    }
                )
                
                if created:
                    self.stdout.write(self.style.SUCCESS(f'Created new season: {season.name}'))
                else:
                    self.stdout.write(f'Using existing season: {season.name}')

                # Get list of countries and filter if needed
                country_list = list(countries)
                if start_from:
                    try:
                        start_index = next(i for i, (code, _) in enumerate(country_list) 
                                         if code == start_from)
                        country_list = country_list[start_index:]
                        self.stdout.write(f'Starting from country: {start_from}')
                    except StopIteration:
                        self.stdout.write(
                            self.style.WARNING(f'Country code {start_from} not found, starting from beginning')
                        )

                self.stdout.write(f'Processing {len(country_list)} countries...')

                with tqdm(total=len(country_list), desc="Processing countries") as pbar:
                    for country_code, country_name in country_list:
                        try:
                            # Check if league exists
                            league = League.objects.filter(
                                country=country_code,
                                level=1
                            ).first()

                            if not league:
                                league = League.objects.create(
                                    country=country_code,
                                    level=1,
                                    name=f"{country_name} Premier League",
                                    max_teams=16,
                                    foreign_players_limit=5
                                )
                                self.stats['leagues_created'] += 1

                            # Check if championship exists
                            championship = Championship.objects.filter(
                                season=season,
                                league=league
                            ).first()

                            if not championship or force:
                                if force and championship:
                                    championship.delete()
                                
                                championship = Championship.objects.create(
                                    season=season,
                                    league=league,
                                    status='pending',
                                    start_date=season.start_date,
                                    end_date=season.end_date
                                )
                                self.stats['championships_created'] += 1

                                # Create teams
                                for i in range(16):
                                    team_name = self.generate_team_name()
                                    team = Club.objects.create(
                                        name=team_name,
                                        country=country_code,
                                        is_bot=True,
                                        owner=None
                                    )
                                    championship.teams.add(team)
                                    self.stats['teams_created'] += 1

                            self.stats['countries_processed'] += 1

                        except Exception as e:
                            self.stdout.write(
                                self.style.ERROR(f'Error processing {country_name}: {str(e)}')
                            )
                            continue
                        finally:
                            pbar.update(1)

                # Print final statistics
                self.stdout.write(self.style.SUCCESS('\nGeneration completed successfully!'))
                self.stdout.write(f"Countries processed: {self.stats['countries_processed']}")
                self.stdout.write(f"Leagues created: {self.stats['leagues_created']}")
                self.stdout.write(f"Championships created: {self.stats['championships_created']}")
                self.stdout.write(f"Teams created: {self.stats['teams_created']}")
                
        except KeyboardInterrupt:
            self.stdout.write(self.style.WARNING('\nProcess interrupted by user'))
            self.stdout.write(f"Countries processed: {self.stats['countries_processed']}")
            self.stdout.write(f"Leagues created: {self.stats['leagues_created']}")
            self.stdout.write(f"Championships created: {self.stats['championships_created']}")
            self.stdout.write(f"Teams created: {self.stats['teams_created']}")
            sys.exit(1)
            
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'\nError during championship generation: {str(e)}')
            )
            raise e

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\generate_championships.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\generate_players_for_all_teams.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from clubs.models import Club
from players.models import Player
from faker import Faker
from players.utils import generate_player_stats
import random

class Command(BaseCommand):
    help = 'Generates players for all teams'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                clubs = Club.objects.all()
                
                for club in clubs:
                    self.stdout.write(f"Generating players for {club.name}...")
                    
                    # Создаем Faker для соответствующей страны
                    fake = Faker(['en_GB'])
                    
                    # Позиции игроков
                    positions = [
                        "Goalkeeper",
                        "Right Back",
                        "Center Back",
                        "Left Back",
                        "Defensive Midfielder",
                        "Central Midfielder",
                        "Attacking Midfielder",
                        "Right Midfielder",
                        "Left Midfielder",
                        "Center Forward"
                    ]
                    
                    # Создаем минимум 25 игроков для каждой команды
                    # Обязательно создаем вратаря
                    self.create_player(club, "Goalkeeper", fake)
                    
                    # Создаем остальных игроков
                    for _ in range(24):
                        position = random.choice(positions)
                        self.create_player(club, position, fake)
                    
                    self.stdout.write(f"Created 25 players for {club.name}")
                
                self.stdout.write(self.style.SUCCESS("All teams populated with players!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error generating players: {str(e)}")
            )
    
    def create_player(self, club, position, fake):
        """Создает одного игрока"""
        # Генерируем уникальное имя
        while True:
            first_name = fake.first_name_male()
            last_name = fake.last_name_male()
            if not Player.objects.filter(first_name=first_name, last_name=last_name).exists():
                break
        
        # Генерируем характеристики
        stats = generate_player_stats(position, random.randint(1, 4))
        
        if position == 'Goalkeeper':
            Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=random.randint(17, 35),
                position=position,
                player_class=random.randint(1, 4),
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                positioning=stats['positioning'],
                reflexes=stats['reflexes'],
                handling=stats['handling'],
                aerial=stats['aerial'],
                jumping=stats['jumping'],
                command=stats['command'],
                throwing=stats['throwing'],
                kicking=stats['kicking']
            )
        else:
            Player.objects.create(
                club=club,
                first_name=first_name,
                last_name=last_name,
                nationality=club.country,
                age=random.randint(17, 35),
                position=position,
                player_class=random.randint(1, 4),
                strength=stats['strength'],
                stamina=stats['stamina'],
                pace=stats['pace'],
                marking=stats['marking'],
                tackling=stats['tackling'],
                work_rate=stats['work_rate'],
                positioning=stats['positioning'],
                passing=stats['passing'],
                crossing=stats['crossing'],
                dribbling=stats['dribbling'],
                ball_control=stats['ball_control'],
                heading=stats['heading'],
                finishing=stats['finishing'],
                long_range=stats['long_range'],
                vision=stats['vision']
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\generate_players_for_all_teams.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\generate_schedule.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import Championship
from tournaments.utils import create_championship_matches, validate_championship_schedule
from django.utils import timezone

class Command(BaseCommand):
    help = 'Generates match schedule for championships'

    def add_arguments(self, parser):
        parser.add_argument(
            '--championship',
            type=int,
            help='ID конкретного чемпионата (если не указан, генерируется для всех активных)'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                if options['championship']:
                    championships = Championship.objects.filter(
                        id=options['championship'],
                        status='pending'
                    )
                else:
                    championships = Championship.objects.filter(
                        season__is_active=True,
                        status='pending'
                    )

                if not championships:
                    self.stdout.write(
                        self.style.WARNING('Нет чемпионатов для генерации расписания')
                    )
                    return

                for championship in championships:
                    try:
                        self.stdout.write(
                            f'Генерация расписания для {championship}...'
                        )
                        
                        create_championship_matches(championship)
                        
                        if validate_championship_schedule(championship):
                            championship.status = 'in_progress'
                            championship.save()
                            
                            self.stdout.write(
                                self.style.SUCCESS(
                                    f'Успешно сгенерировано расписание для {championship}'
                                )
                            )
                        else:
                            raise ValueError(
                                f'Ошибка валидации расписания для {championship}'
                            )
                            
                    except Exception as e:
                        self.stdout.write(
                            self.style.ERROR(f'Ошибка для {championship}: {str(e)}')
                        )
                        raise

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Ошибка генерации расписания: {str(e)}')
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\generate_schedule.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\handle_season_transitions.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import Championship, Season, League
from django.db.models import F
from django.core.exceptions import ValidationError

class Command(BaseCommand):
    help = 'Process end of season transitions between divisions'

    def add_arguments(self, parser):
        parser.add_argument(
            '--season',
            type=int,
            help='Season number to process (defaults to active season)'
        )

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем сезон для обработки
                season_number = options.get('season')
                if season_number:
                    season = Season.objects.get(number=season_number)
                else:
                    season = Season.objects.get(is_active=True)

                self.stdout.write(f"Processing end of season transitions for {season}")

                # Получаем все чемпионаты текущего сезона
                championships = Championship.objects.filter(
                    season=season
                ).select_related('league')

                # Группируем чемпионаты по странам
                countries = {}
                for champ in championships:
                    country_code = champ.league.country.code
                    if country_code not in countries:
                        countries[country_code] = {'div1': None, 'div2': None}
                    
                    if champ.league.level == 1:
                        countries[country_code]['div1'] = champ
                    elif champ.league.level == 2:
                        countries[country_code]['div2'] = champ

                # Обрабатываем каждую страну
                for country_code, divisions in countries.items():
                    if not divisions['div1'] or not divisions['div2']:
                        self.stdout.write(
                            self.style.WARNING(
                                f"Skipping {country_code} - missing division"
                            )
                        )
                        continue

                    self.process_country_transitions(
                        divisions['div1'], 
                        divisions['div2']
                    )

        except Season.DoesNotExist:
            self.stdout.write(
                self.style.ERROR("No active season found!")
            )
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error during transitions: {str(e)}")
            )
            raise

    def process_country_transitions(self, div1_championship, div2_championship):
        """
        Обработка переходов между дивизионами для одной страны
        """
        country_name = div1_championship.league.country.name
        self.stdout.write(f"\nProcessing {country_name}:")

        try:
            # Получаем команды для понижения (2 последние из первого дивизиона)
            relegated_teams = (
                div1_championship.championshipteam_set
                .annotate(
                    goals_diff=F('goals_for') - F('goals_against')
                )
                .order_by(
                    'points',
                    'goals_diff',
                    'goals_for'
                )[:2]
            )

            # Получаем команды для повышения (2 первые из второго дивизиона)
            promoted_teams = (
                div2_championship.championshipteam_set
                .annotate(
                    goals_diff=F('goals_for') - F('goals_against')
                )
                .order_by(
                    '-points',
                    '-goals_diff',
                    '-goals_for'
                )[:2]
            )

            # Применяем переходы
            div2_league = div2_championship.league
            div1_league = div1_championship.league

            # Понижаем команды
            for team_stats in relegated_teams:
                team = team_stats.team
                team.league = div2_league
                team.save()
                self.stdout.write(
                    f"  Relegated: {team.name} "
                    f"(Points: {team_stats.points}, "
                    f"GD: {team_stats.goals_diff})"
                )

            # Повышаем команды
            for team_stats in promoted_teams:
                team = team_stats.team
                team.league = div1_league
                team.save()
                self.stdout.write(
                    f"  Promoted: {team.name} "
                    f"(Points: {team_stats.points}, "
                    f"GD: {team_stats.goals_diff})"
                )

        except Exception as e:
            raise ValidationError(
                f"Error processing transitions for {country_name}: {str(e)}"
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\handle_season_transitions.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\initialize_football_world.py ---


# --- ????? ????? C:\realfootballsim\tournaments\management\commands\initialize_football_world.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\initialize_top_leagues.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League

class Command(BaseCommand):
    help = 'Initialize leagues for top 10 football countries'

    def handle(self, *args, **options):
        # Топ-10 футбольных стран
        TOP_LEAGUES = [
            {
                'country': 'GB',
                'div1_name': 'Premier League',
                'div2_name': 'Championship'
            },
            {
                'country': 'ES',
                'div1_name': 'La Liga',
                'div2_name': 'La Liga 2'
            },
            {
                'country': 'IT',
                'div1_name': 'Serie A',
                'div2_name': 'Serie B'
            },
            {
                'country': 'DE',
                'div1_name': 'Bundesliga',
                'div2_name': '2. Bundesliga'
            },
            {
                'country': 'FR',
                'div1_name': 'Ligue 1',
                'div2_name': 'Ligue 2'
            },
            {
                'country': 'PT',
                'div1_name': 'Primeira Liga',
                'div2_name': 'Liga Portugal 2'
            },
            {
                'country': 'GR',
                'div1_name': 'Super League',
                'div2_name': 'Super League 2'
            },
            {
                'country': 'RU',
                'div1_name': 'Premier League',
                'div2_name': 'First League'
            },
            {
                'country': 'AR',
                'div1_name': 'Primera División',
                'div2_name': 'Primera Nacional'
            },
            {
                'country': 'BR',
                'div1_name': 'Série A',
                'div2_name': 'Série B'
            },
        ]

        try:
            with transaction.atomic():
                # Удаляем все существующие лиги
                League.objects.all().delete()
                
                for league_info in TOP_LEAGUES:
                    # Создаем первый дивизион
                    League.objects.create(
                        name=f"{league_info['country']} {league_info['div1_name']}", # добавляем страну в название
                        country=league_info['country'],
                        level=1,
                        max_teams=16,
                        foreign_players_limit=5
                    )
                    self.stdout.write(
                        f"Created {league_info['div1_name']} for {league_info['country']}"
                    )
                    
                    # Создаем второй дивизион
                    League.objects.create(
                        name=f"{league_info['country']} {league_info['div2_name']}", # добавляем страну в название
                        country=league_info['country'],
                        level=2,
                        max_teams=16,
                        foreign_players_limit=5
                    )
                    self.stdout.write(
                        f"Created {league_info['div2_name']} for {league_info['country']}"
                    )

                self.stdout.write(
                    self.style.SUCCESS(
                        f'Successfully created leagues for {len(TOP_LEAGUES)} countries'
                    )
                )
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error creating leagues: {str(e)}')
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\initialize_top_leagues.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\populate_first_divisions.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League
from clubs.models import Club
from faker import Faker
import random

class Command(BaseCommand):
    help = 'Populates first divisions with bot teams'

    def __init__(self):
        super().__init__()
        self.team_adjectives = [
            'United', 'City', 'Athletic', 'Rovers', 'Wanderers', 
            'Rangers', 'Dynamo', 'Sporting', 'Real', 'Inter',
            'Academy', 'Warriors', 'Legion', 'Phoenix', 'Union'
        ]
        self.team_suffixes = ['FC', 'CF', 'SC', 'AF']

    def generate_team_name(self, fake):
        """Генерирует уникальное название команды"""
        attempts = 0
        while attempts < 100:
            city = fake.city()
            variant = random.choice([
                f"{city} {random.choice(self.team_adjectives)}",
                f"{random.choice(self.team_adjectives)} {city}",
                f"{city} {random.choice(self.team_suffixes)}"
            ])
            if not Club.objects.filter(name=variant).exists():
                return variant
            attempts += 1
        raise Exception("Не удалось создать уникальное имя команды")

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем все первые дивизионы
                first_divisions = League.objects.filter(level=1)
                
                for league in first_divisions:
                    self.stdout.write(f"Populating {league.name}...")
                    
                    # Проверяем, сколько команд уже есть
                    existing_teams = Club.objects.filter(league=league).count()
                    if existing_teams >= 16:
                        self.stdout.write(f"League {league.name} already has {existing_teams} teams")
                        continue
                    
                    # Создаем Faker для соответствующей страны
                    fake = Faker(['en_GB'])  # Можно добавить больше локалей
                    
                    # Добавляем команды до 16
                    teams_to_create = 16 - existing_teams
                    for _ in range(teams_to_create):
                        team_name = self.generate_team_name(fake)
                        Club.objects.create(
                            name=team_name,
                            country=league.country,
                            league=league,
                            is_bot=True
                        )
                        self.stdout.write(f"Created team: {team_name}")
                    
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Successfully populated {league.name} with {teams_to_create} teams"
                        )
                    )
                
                self.stdout.write(self.style.SUCCESS("All first divisions populated!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error populating first divisions: {str(e)}")
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\populate_first_divisions.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\populate_second_divisions.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from tournaments.models import League
from clubs.models import Club
from faker import Faker
import random

class Command(BaseCommand):
    help = 'Populates second divisions with bot teams'

    def __init__(self):
        super().__init__()
        self.team_adjectives = [
            'United', 'City', 'Athletic', 'Rovers', 'Wanderers', 
            'Rangers', 'Dynamo', 'Sporting', 'Real', 'Inter',
            'Academy', 'Warriors', 'Legion', 'Phoenix', 'Union'
        ]
        self.team_suffixes = ['FC', 'CF', 'SC', 'AF']

    def generate_team_name(self, fake):
        """Генерирует уникальное название команды"""
        attempts = 0
        while attempts < 100:
            city = fake.city()
            variant = random.choice([
                f"{city} {random.choice(self.team_adjectives)}",
                f"{random.choice(self.team_adjectives)} {city}",
                f"{city} {random.choice(self.team_suffixes)}"
            ])
            if not Club.objects.filter(name=variant).exists():
                return variant
            attempts += 1
        raise Exception("Не удалось создать уникальное имя команды")

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # Получаем все вторые дивизионы
                second_divisions = League.objects.filter(level=2)
                
                for league in second_divisions:
                    self.stdout.write(f"Populating {league.name}...")
                    
                    # Проверяем, сколько команд уже есть
                    existing_teams = Club.objects.filter(league=league).count()
                    if existing_teams >= 16:
                        self.stdout.write(f"League {league.name} already has {existing_teams} teams")
                        continue
                    
                    # Создаем Faker для соответствующей страны
                    fake = Faker(['en_GB'])  # Можно добавить больше локалей
                    
                    # Добавляем команды до 16
                    teams_to_create = 16 - existing_teams
                    for _ in range(teams_to_create):
                        team_name = self.generate_team_name(fake)
                        Club.objects.create(
                            name=team_name,
                            country=league.country,
                            league=league,
                            is_bot=True
                        )
                        self.stdout.write(f"Created team: {team_name}")
                    
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Successfully populated {league.name} with {teams_to_create} teams"
                        )
                    )
                
                self.stdout.write(self.style.SUCCESS("All second divisions populated!"))
                
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error populating second divisions: {str(e)}")
            )

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\populate_second_divisions.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\reset_season.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone
from datetime import datetime, date
from tournaments.models import Season, Championship, ChampionshipMatch
from tournaments.utils import create_championship_matches
from matches.match_simulation import simulate_match
from matches.models import Match
from clubs.models import Club

class Command(BaseCommand):
    help = 'Resets and creates new first season starting from November 2024'

    def handle(self, *args, **options):
        try:
            with transaction.atomic():
                # 1. Удаляем все существующие сезоны и связанные данные
                self.stdout.write("Deleting existing seasons and matches...")
                Season.objects.all().delete()  # Это также удалит связанные чемпионаты и матчи

                # 2. Создаем новый первый сезон
                season = Season.objects.create(
                    name="November 2024",
                    number=1,  # Первый сезон
                    start_date=date(2024, 11, 1),
                    end_date=date(2025, 5, 31),
                    is_active=True
                )
                self.stdout.write(self.style.SUCCESS(f"Created new season: {season.name}"))

                # 3. Создаем чемпионаты для всех лиг
                from tournaments.models import League
                leagues = League.objects.all()
                championships_created = 0

                for league in leagues:
                    # Получаем команды для этой лиги
                    bot_teams = Club.objects.filter(league=league, is_bot=True)
                    human_teams = Club.objects.filter(league=league, is_bot=False)
                    total_teams = bot_teams.count() + human_teams.count()
                    
                    # Проверяем, что в лиге ровно 16 команд (боты + человеческие)
                    if total_teams != 16:
                        self.stdout.write(self.style.WARNING(
                            f"Skipping {league.name} - has {total_teams} teams "
                            f"({bot_teams.count()} bots, {human_teams.count()} human)"
                        ))
                        continue

                    championship = Championship.objects.create(
                        season=season,
                        league=league,
                        status='in_progress',  # Так как сезон уже идёт
                        start_date=season.start_date,
                        end_date=season.end_date
                    )
                    
                    # Добавляем все команды в чемпионат
                    for team in list(bot_teams) + list(human_teams):
                        championship.teams.add(team)

                    # Генерируем расписание
                    create_championship_matches(championship)
                    championships_created += 1

                self.stdout.write(self.style.SUCCESS(
                    f"Created {championships_created} championships"
                ))

                # 4. Симулируем матчи с 1 по 7 ноября
                # Используем timezone.make_aware для создания datetime с часовым поясом
                current_date = timezone.make_aware(
                    datetime(2024, 11, 8, 0, 0, 0)
                )
                
                past_matches = Match.objects.filter(
                    date__lt=current_date,
                    status='scheduled'
                )

                matches_simulated = 0
                for match in past_matches:
                    simulate_match(match.id)
                    matches_simulated += 1

                self.stdout.write(self.style.SUCCESS(
                    f"Simulated {matches_simulated} past matches"
                ))

        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error occurred: {str(e)}"))
            raise e

        self.stdout.write(self.style.SUCCESS("Season reset completed successfully!"))

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\reset_season.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\run_match_checker.py ---

from django.core.management.base import BaseCommand
from django.utils import timezone
import time
from matches.models import Match
from matches.match_simulation import simulate_match
import logging

logger = logging.getLogger('matches')

class Command(BaseCommand):
    help = 'Continuously checks and simulates matches'

    def handle(self, *args, **options):
        self.stdout.write('Starting match checker...')
        
        while True:
            try:
                now = timezone.now()
                self.stdout.write(f'Checking matches at {now}')
                
                # Находим матчи для симуляции
                matches = Match.objects.filter(
                    status='scheduled',
                    date__lte=now
                ).select_related('home_team', 'away_team')
                
                if matches.exists():
                    self.stdout.write(f'Found {matches.count()} matches to simulate')
                    
                    for match in matches:
                        try:
                            self.stdout.write(f'Simulating: {match.home_team} vs {match.away_team}')
                            simulate_match(match.id)
                            match.refresh_from_db()
                            self.stdout.write(
                                self.style.SUCCESS(
                                    f'Simulated: {match.home_team} {match.home_score} - {match.away_score} {match.away_team}'
                                )
                            )
                        except Exception as e:
                            self.stdout.write(
                                self.style.ERROR(f'Error simulating match {match.id}: {str(e)}')
                            )
                
                # Ждем 10 секунд перед следующей проверкой
                time.sleep(10)
                
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'Error in match checker: {str(e)}')
                )
                time.sleep(10)

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\run_match_checker.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\test_match.py ---

from django.core.management.base import BaseCommand
from django.utils import timezone
from clubs.models import Club
from matches.models import Match
from matches.match_simulation import MatchSimulation
import random

class Command(BaseCommand):
    help = 'Tests match simulation with random teams'

    def handle(self, *args, **options):
        try:
            # Получаем две случайные команды
            teams = list(Club.objects.all().order_by('?')[:2])
            if len(teams) < 2:
                self.stdout.write(self.style.ERROR('Недостаточно команд в базе данных'))
                return

            home_team = teams[0]
            away_team = teams[1]

            # Выводим информацию о командах до создания матча
            self.stdout.write('\nИнформация о командах:')
            self.stdout.write(f'\nДомашняя команда: {home_team.name}')
            self.stdout.write(f'Количество игроков: {home_team.player_set.count()}')
            
            self.stdout.write(f'\nГостевая команда: {away_team.name}')
            self.stdout.write(f'Количество игроков: {away_team.player_set.count()}\n')

            # Создаем тестовый матч
            match = Match.objects.create(
                home_team=home_team,
                away_team=away_team,
                date=timezone.now(),
                status='scheduled'
            )

            # Инициализируем симуляцию
            simulation = MatchSimulation(match)
            
            # Симулируем матч
            self.stdout.write('\n=== НАЧАЛО МАТЧА ===\n')
            
            for minute in range(90):
                if minute % 15 == 0:  # Каждые 15 минут показываем статус
                    self.stdout.write(f'\n=== {minute} МИНУТА ===')
                    self.stdout.write(f'Счет: {match.home_score} - {match.away_score}')
                    self.stdout.write(f'Владение мячом: {simulation.match_stats["home"]["possession"]}% - {simulation.match_stats["away"]["possession"]}%')
                    self.stdout.write(f'Удары (в створ): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]}) - {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
                
                simulation.simulate_minute(minute)
            
            # Вывод итоговой статистики
            self.stdout.write('\n=== ИТОГОВАЯ СТАТИСТИКА ===')
            self.stdout.write(f'\nИтоговый счет: {match.home_score} - {match.away_score}')
            self.stdout.write('\nСтатистика домашней команды:')
            self.stdout.write(f'Владение мячом: {simulation.match_stats["home"]["possession"]}%')
            self.stdout.write(f'Удары (в створ): {simulation.match_stats["home"]["shots"]} ({simulation.match_stats["home"]["shots_on_target"]})')
            self.stdout.write(f'Угловые: {simulation.match_stats["home"]["corners"]}')
            self.stdout.write(f'Фолы: {simulation.match_stats["home"]["fouls"]}')
            self.stdout.write(f'Атаки (опасные): {simulation.match_stats["home"]["attacks"]} ({simulation.match_stats["home"]["dangerous_attacks"]})')
            
            self.stdout.write('\nСтатистика гостевой команды:')
            self.stdout.write(f'Владение мячом: {simulation.match_stats["away"]["possession"]}%')
            self.stdout.write(f'Удары (в створ): {simulation.match_stats["away"]["shots"]} ({simulation.match_stats["away"]["shots_on_target"]})')
            self.stdout.write(f'Угловые: {simulation.match_stats["away"]["corners"]}')
            self.stdout.write(f'Фолы: {simulation.match_stats["away"]["fouls"]}')
            self.stdout.write(f'Атаки (опасные): {simulation.match_stats["away"]["attacks"]} ({simulation.match_stats["away"]["dangerous_attacks"]})')
            
            # События матча
            self.stdout.write('\n=== СОБЫТИЯ МАТЧА ===')
            events = match.events.all().order_by('minute')
            for event in events:
                self.stdout.write(f'{event.minute}\' - {event.description}')

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'\nПроизошла ошибка: {str(e)}'))

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\test_match.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\test_prematch.py ---

from django.core.management.base import BaseCommand
from django.utils import timezone
from clubs.models import Club
from matches.models import Match
from matches.match_preparation import PreMatchPreparation
import random

class Command(BaseCommand):
    help = 'Tests prematch preparation with random teams'

    def handle(self, *args, **options):
        try:
            # Получаем две случайные команды
            teams = list(Club.objects.all().order_by('?')[:2])
            if len(teams) < 2:
                self.stdout.write(self.style.ERROR('Недостаточно команд в базе данных'))
                return

            home_team = teams[0]
            away_team = teams[1]

            # Выводим информацию о командах до создания матча
            self.stdout.write('\nИнформация о командах:')
            self.stdout.write(f'\nДомашняя команда: {home_team.name}')
            self.stdout.write(f'Количество игроков: {home_team.player_set.count()}')
            
            self.stdout.write(f'\nГостевая команда: {away_team.name}')
            self.stdout.write(f'Количество игроков: {away_team.player_set.count()}\n')

            # Создаем тестовый матч
            match = Match.objects.create(
                home_team=home_team,
                away_team=away_team,
                date=timezone.now(),
                status='scheduled'
            )

            # Инициализируем подготовку матча
            prep = PreMatchPreparation(match)
            
            # Проводим подготовку
            if prep.prepare_match():
                self.stdout.write(self.style.SUCCESS('\nПредматчевая подготовка успешна!\n'))
                
                # Выводим информацию о командах
                self.stdout.write('\n=== ИНФОРМАЦИЯ О КОМАНДАХ ===')
                self.stdout.write(f'\nДомашняя команда: {home_team.name}')
                self.stdout.write(f'Гостевая команда: {away_team.name}\n')
                
                # Выводим общую силу команд
                self.stdout.write('\n=== ОБЩАЯ СИЛА КОМАНД ===')
                self.stdout.write(f'Домашняя команда: {prep.team_strengths["home"]}')
                self.stdout.write(f'Гостевая команда: {prep.team_strengths["away"]}\n')
                
                # Выводим детальные параметры
                self.stdout.write('\n=== ПАРАМЕТРЫ ДОМАШНЕЙ КОМАНДЫ ===')
                home_params = prep.match_parameters['home']
                self.stdout.write(f'Атака: {home_params["team_attack"]}')
                self.stdout.write(f'Оборона: {home_params["team_defense"]}')
                self.stdout.write(f'Полузащита: {home_params["team_midfield"]}')
                self.stdout.write(f'Сила вратаря: {home_params["goalkeeper_strength"]}\n')
                
                self.stdout.write('\n=== ПАРАМЕТРЫ ГОСТЕВОЙ КОМАНДЫ ===')
                away_params = prep.match_parameters['away']
                self.stdout.write(f'Атака: {away_params["team_attack"]}')
                self.stdout.write(f'Оборона: {away_params["team_defense"]}')
                self.stdout.write(f'Полузащита: {away_params["team_midfield"]}')
                self.stdout.write(f'Сила вратаря: {away_params["goalkeeper_strength"]}\n')
                
            else:
                self.stdout.write(self.style.ERROR('\nОшибки при подготовке матча:'))
                for error in prep.get_validation_errors():
                    self.stdout.write(self.style.ERROR(f'- {error}'))
            
            # Удаляем тестовый матч
            match.delete()

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'\nПроизошла ошибка: {str(e)}'))

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\test_prematch.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\management\commands\update_club_matches.py ---

from django.core.management.base import BaseCommand
from django.db import transaction
from django.db.models import Q
from tournaments.models import Championship, ChampionshipMatch
from matches.models import Match
from clubs.models import Club
import logging

logger = logging.getLogger(__name__)

def update_matches_for_replaced_team(championship, old_team_id, new_team):
    """
    Обновляет все матчи, заменяя old_team на new_team
    """
    try:
        with transaction.atomic():
            # Найти все матчи, где участвовала старая команда
            matches = Match.objects.filter(
                championshipmatch__championship=championship
            ).filter(
                Q(home_team_id=old_team_id) |
                Q(away_team_id=old_team_id)
            )
            
            updated_count = 0
            # Обновить все найденные матчи
            for match in matches:
                if match.home_team_id == old_team_id:
                    match.home_team = new_team
                    updated_count += 1
                if match.away_team_id == old_team_id:
                    match.away_team = new_team
                    updated_count += 1
                match.save()
                logger.info(f"Updated match {match.id}: {match.home_team} vs {match.away_team}")
            
            return updated_count  # Возвращаем количество обновленных матчей
    except Exception as e:
        logger.error(f"Error updating matches: {str(e)}")
        raise

class Command(BaseCommand):
    help = 'Updates championship matches for a club, replacing a bot team'

    def add_arguments(self, parser):
        parser.add_argument('club_id', type=int, help='ID of the club to update matches for')

    def handle(self, *args, **options):
        club_id = options['club_id']
        
        try:
            with transaction.atomic():
                # Получаем клуб
                club = Club.objects.get(id=club_id)
                self.stdout.write(f"Found club: {club.name} (ID: {club.id})")
                
                # Находим активный чемпионат для страны клуба
                championship = Championship.objects.get(
                    league__country=club.country,
                    league__level=1,
                    season__is_active=True
                )
                self.stdout.write(f"Found championship: {championship}")

                # Проверяем, есть ли клуб в чемпионате
                is_in_championship = championship.teams.filter(id=club.id).exists()
                if not is_in_championship:
                    self.stdout.write(self.style.ERROR(f"Club {club.name} is not part of championship {championship}"))
                    return

                # Получаем все матчи чемпионата
                matches = Match.objects.filter(
                    championshipmatch__championship=championship
                )

                # Находим матчи, где клуб должен участвовать
                team_matches = matches.filter(
                    Q(home_team=club) |
                    Q(away_team=club)
                ).count()

                if team_matches == 0:
                    # Клуб в чемпионате, но нет матчей - ищем бота, которого он заменил
                    self.stdout.write("Looking for replaced bot team...")
                    
                    # Выводим все команды в чемпионате для отладки
                    self.stdout.write("\nTeams in championship:")
                    for team in championship.teams.all():
                        self.stdout.write(f"- {team.name} (ID: {team.id}, Bot: {team.is_bot})")
                    
                    # Проверяем статистику
                    from tournaments.models import ChampionshipTeam
                    team_stats = ChampionshipTeam.objects.filter(
                        championship=championship,
                        team=club
                    ).first()
                    
                    if team_stats:
                        self.stdout.write(f"\nFound team statistics:")
                        self.stdout.write(f"Points: {team_stats.points}")
                        self.stdout.write(f"Matches played: {team_stats.matches_played}")
                    else:
                        self.stdout.write(self.style.WARNING("No team statistics found!"))

                    # Выводим пример нескольких матчей для отладки
                    self.stdout.write("\nSample matches in championship:")
                    for match in matches[:5]:
                        self.stdout.write(
                            f"- {match.home_team.name} vs {match.away_team.name}"
                        )

                    # Находим команды-боты с таким же количеством очков
                    if team_stats:
                        potential_bots = ChampionshipTeam.objects.filter(
                            championship=championship,
                            points=team_stats.points,
                            team__is_bot=True
                        )
                        
                        self.stdout.write(f"\nFound {potential_bots.count()} potential bot matches:")
                        for bot_stats in potential_bots:
                            self.stdout.write(
                                f"- {bot_stats.team.name} "
                                f"(Points: {bot_stats.points}, "
                                f"Matches: {bot_stats.matches_played})"
                            )
                    
                    # Спрашиваем пользователя об ID бота
                    bot_id = input("\nEnter the ID of the bot team to replace: ")
                    try:
                        bot_id = int(bot_id)
                        replaced_matches = update_matches_for_replaced_team(
                            championship=championship,
                            old_team_id=bot_id,
                            new_team=club
                        )
                        self.stdout.write(
                            self.style.SUCCESS(
                                f"Successfully updated {replaced_matches} matches "
                                f"for club {club.name}"
                            )
                        )
                    except ValueError:
                        self.stdout.write(self.style.ERROR("Invalid bot ID!"))
                else:
                    self.stdout.write(
                        self.style.SUCCESS(
                            f"Club {club.name} already has {team_matches} matches "
                            f"in championship {championship}"
                        )
                    )

        except Club.DoesNotExist:
            self.stdout.write(self.style.ERROR(f"Club with ID {club_id} not found"))
        except Championship.DoesNotExist:
            self.stdout.write(
                self.style.ERROR(
                    f"No active championship found for club {club.name} "
                    f"in country {club.country}"
                )
            )
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"Error: {str(e)}"))

# --- ????? ????? C:\realfootballsim\tournaments\management\commands\update_club_matches.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\migrations\0001_initial.py ---

# Generated by Django 5.0.1 on 2024-12-07 04:02

import datetime
import django.db.models.deletion
import django_countries.fields
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('clubs', '0001_initial'),
        ('matches', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Championship',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('in_progress', 'In Progress'), ('finished', 'Finished')], default='pending', max_length=20)),
                ('start_date', models.DateField()),
                ('end_date', models.DateField()),
                ('match_time', models.TimeField(default=datetime.time(18, 0), help_text='Match start time (UTC)')),
            ],
        ),
        migrations.CreateModel(
            name='Season',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('number', models.PositiveIntegerField(help_text='Порядковый номер сезона', unique=True)),
                ('name', models.CharField(max_length=100)),
                ('start_date', models.DateField()),
                ('end_date', models.DateField()),
                ('is_active', models.BooleanField(default=False)),
            ],
            options={
                'ordering': ['-start_date'],
            },
        ),
        migrations.CreateModel(
            name='ChampionshipMatch',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('round', models.PositiveIntegerField()),
                ('match_day', models.PositiveIntegerField()),
                ('processed', models.BooleanField(default=False)),
                ('championship', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='tournaments.championship')),
                ('match', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='matches.match')),
            ],
            options={
                'ordering': ['round', 'match_day'],
            },
        ),
        migrations.CreateModel(
            name='ChampionshipTeam',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('points', models.PositiveIntegerField(default=0)),
                ('matches_played', models.PositiveIntegerField(default=0)),
                ('wins', models.PositiveIntegerField(default=0)),
                ('draws', models.PositiveIntegerField(default=0)),
                ('losses', models.PositiveIntegerField(default=0)),
                ('goals_for', models.PositiveIntegerField(default=0)),
                ('goals_against', models.PositiveIntegerField(default=0)),
                ('championship', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='tournaments.championship')),
                ('team', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='clubs.club')),
            ],
            options={
                'ordering': ['-points', '-goals_for'],
                'unique_together': {('championship', 'team')},
            },
        ),
        migrations.AddField(
            model_name='championship',
            name='teams',
            field=models.ManyToManyField(through='tournaments.ChampionshipTeam', to='clubs.club'),
        ),
        migrations.CreateModel(
            name='League',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('country', django_countries.fields.CountryField(max_length=2)),
                ('level', models.PositiveIntegerField()),
                ('max_teams', models.PositiveIntegerField(default=16)),
                ('foreign_players_limit', models.PositiveIntegerField(default=5, help_text='Maximum number of foreign players allowed in match squad')),
            ],
            options={
                'ordering': ['country', 'level'],
                'unique_together': {('country', 'level')},
            },
        ),
        migrations.AddField(
            model_name='championship',
            name='league',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='tournaments.league'),
        ),
        migrations.AddField(
            model_name='championship',
            name='season',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='tournaments.season'),
        ),
        migrations.AlterUniqueTogether(
            name='championship',
            unique_together={('season', 'league')},
        ),
    ]

# --- ????? ????? C:\realfootballsim\tournaments\migrations\0001_initial.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\migrations\__init__.py ---


# --- ????? ????? C:\realfootballsim\tournaments\migrations\__init__.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\static\tournaments\js\calendar.js ---

document.addEventListener('DOMContentLoaded', function() {
    // Инициализация календаря
    const calendarEl = document.getElementById('calendar');
    if (!calendarEl) return;

    const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        headerToolbar: {
            left: 'prev,next today',
            center: 'title',
            right: 'dayGridMonth,timeGridWeek,timeGridDay'
        },
        events: calendarEvents,
        eventTimeFormat: {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
            meridiem: false
        },
        eventClick: function(info) {
            if (info.event.url) {
                window.location.href = info.event.url;
                info.jsEvent.preventDefault();
            }
        },
        eventDidMount: function(info) {
            // Добавляем тултип с деталями матча
            const event = info.event;
            let tooltipContent = `${event.title}<br>`;
            if (event.extendedProps.status === 'finished') {
                tooltipContent += `Score: ${event.extendedProps.score}`;
            } else {
                tooltipContent += event.extendedProps.status;
            }
            
            new bootstrap.Tooltip(info.el, {
                title: tooltipContent,
                html: true,
                placement: 'top',
                customClass: 'match-tooltip'
            });
        }
    });

    calendar.render();
});

// Функция для обновления отображения времени
function updateMatchTimes(timezone) {
    document.querySelectorAll('.match-time').forEach(function(el) {
        const utcTime = moment.utc(el.dataset.utc);
        el.textContent = utcTime.tz(timezone).format('DD MMM HH:mm');
    });
    
    if (typeof calendar !== 'undefined') {
        calendar.setOption('timeZone', timezone);
        calendar.refetchEvents();
    }
}

# --- ????? ????? C:\realfootballsim\tournaments\static\tournaments\js\calendar.js ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\base.html ---

{% extends 'core/base.html' %}

{% block content %}
<div class="row">
    <div class="col-12">
        <nav class="mb-4">
            <div class="d-flex justify-content-between align-items-center">
                <ul class="nav nav-tabs">
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'championship_list' %}active{% endif %}" 
                           href="{% url 'tournaments:championship_list' %}">Championships</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'season_list' %}active{% endif %}" 
                           href="{% url 'tournaments:season_list' %}">Seasons</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link {% if request.resolver_match.url_name == 'league_list' %}active{% endif %}" 
                           href="{% url 'tournaments:league_list' %}">Leagues</a>
                    </li>
                </ul>
                
                <div style="width: 200px;">
                    {% include 'tournaments/timezone_selector.html' %}
                </div>
            </div>
        </nav>
        
        {% block tournament_content %}{% endblock %}
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\base.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\championship_detail.html ---

{% extends 'tournaments/base.html' %}
{% load static %}

{% block tournament_content %}
<div class="row">
    <!-- Header Section - оставляем без изменений -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h2>{{ championship.league.name }}</h2>
                        <p class="text-muted mb-0">
                            {{ championship.league.country.name }} - Division {{ championship.league.level }}
                        </p>
                        <p class="text-muted">
                            Season: {{ championship.season.name }} | 
                            Status: {{ championship.get_status_display }} |
                            Match Time: <span id="match-time" utc-time="{{ championship.match_time|time:'H:i' }}"></span>
                        </p>
                    </div>
                    <div>
                        <button class="btn btn-outline-secondary" data-bs-toggle="modal" data-bs-target="#timezonesModal">
                            Change Timezone
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- League Table -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">League Table</h3>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Team</th>
                                <th>MP</th>
                                <th>W</th>
                                <th>D</th>
                                <th>L</th>
                                <th>GF</th>
                                <th>GA</th>
                                <th>GD</th>
                                <th>Pts</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for team in standings %}
                            <tr>
                                <td>{{ forloop.counter }}</td>
                                <td>
                                    <a href="{% url 'clubs:club_detail' team.team.id %}" class="text-decoration-none">
                                        {{ team.team.name }}
                                        {% if team.team.is_bot %}
                                            <small class="text-muted">(Bot)</small>
                                        {% endif %}
                                    </a>
                                </td>
                                <td>{{ team.matches_played }}</td>
                                <td>{{ team.wins }}</td>
                                <td>{{ team.draws }}</td>
                                <td>{{ team.losses }}</td>
                                <td>{{ team.goals_for }}</td>
                                <td>{{ team.goals_against }}</td>
                                <td>{% if team.goals_diff > 0 %}+{% endif %}{{ team.goals_diff }}</td>
                                <td><strong>{{ team.points }}</strong></td>
                            </tr>
                            {% empty %}
                            <tr>
                                <td colspan="10" class="text-center">No teams in championship</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Matches Section -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">Matches</h3>
            </div>
            <div class="card-body">
                {% if matches %}
                    {% regroup matches by round as round_list %}
                    {% for round in round_list %}
                    <div class="mb-4">
                        <h4 class="h6">Round {{ round.grouper }}</h4>
                        <div class="list-group">
                            {% for match in round.list %}
                            <div class="list-group-item">
                                <div class="d-flex justify-content-between align-items-center">
                                    <small>{{ match.match.date }}</small>
                                    <span class="badge {% if match.match.status == 'finished' %}bg-success{% elif match.match.status == 'in_progress' %}bg-warning{% else %}bg-secondary{% endif %}">
                                        {{ match.match.get_status_display }}
                                    </span>
                                </div>
                                <div class="d-flex justify-content-between align-items-center mt-2">
                                    <a href="{% url 'clubs:club_detail' match.match.home_team.id %}" class="text-decoration-none">
                                        {{ match.match.home_team.name }}
                                        {% if match.match.home_team.is_bot %}
                                            <small>(Bot)</small>
                                        {% endif %}
                                    </a>
                                    {% if match.match.status == 'finished' %}
                                        <strong>{{ match.match.home_score }} - {{ match.match.away_score }}</strong>
                                    {% else %}
                                        <span>vs</span>
                                    {% endif %}
                                    <a href="{% url 'clubs:club_detail' match.match.away_team.id %}" class="text-decoration-none">
                                        {{ match.match.away_team.name }}
                                        {% if match.match.away_team.is_bot %}
                                            <small>(Bot)</small>
                                        {% endif %}
                                    </a>
                                </div>
                            </div>
                            {% endfor %}
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <p class="text-center">No matches scheduled</p>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Timezone Modal -->
<div class="modal fade timezone-modal" id="timezonesModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select Timezone</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                {% include 'tournaments/timezone_selector.html' %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\championship_detail.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\championship_list.html ---

{% extends 'tournaments/base.html' %}

{% block tournament_content %}
<div class="row">
    <div class="col-12">
        <h2 class="mb-4">Championships</h2>

        {% if active_seasons %}
        <div class="mb-5">
            <h3>Active Seasons</h3>
            {% for season in active_seasons %}
            <div class="card mb-4">
                <div class="card-header">
                    <h4 class="mb-0">{{ season.name }}</h4>
                </div>
                <div class="card-body">
                    {% regroup championships|dictsort:"league.country" by league.country as country_list %}
                    {% for country in country_list %}
                    {% if country.list|length > 0 %}
                    <h5 class="mt-3">{{ country.grouper }}</h5>
                    <div class="row">
                        {% for championship in country.list %}
                        {% if championship.season == season %}
                        <div class="col-md-6 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">{{ championship.league.name }}</h5>
                                    <p class="text-muted small">Division {{ championship.league.level }}</p>
                                    <p class="card-text">
                                        Status: {{ championship.get_status_display }}<br>
                                        Teams: {{ championship.teams.count }}/{{ championship.league.max_teams }}
                                    </p>
                                    {% if championship.teams.count > 0 %}
                                    <small class="text-muted">Participating teams:</small>
                                    <div class="mt-2 small">
                                        {% for team in championship.teams.all|slice:":5" %}
                                        <a href="{% url 'clubs:club_detail' team.id %}" class="text-decoration-none">
                                            {{ team.name }}{% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if championship.teams.count > 5 %}
                                        <span class="text-muted">and {{ championship.teams.count|add:"-5" }} more...</span>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                <div class="card-footer bg-transparent">
                                    <a href="{% url 'tournaments:championship_detail' championship.pk %}" 
                                       class="btn btn-primary btn-sm">View Details</a>
                                </div>
                            </div>
                        </div>
                        {% endif %}
                        {% endfor %}
                    </div>
                    {% endif %}
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
        </div>
        {% endif %}

        <div class="mb-4">
            <h3>All Championships</h3>
            {% regroup championships|dictsort:"league.country.name" by league.country.name as country_list %}
            {% for country in country_list %}
            <div class="card mb-4">
                <div class="card-header">
                    <h4 class="mb-0">{{ country.grouper }}</h4>
                </div>
                <div class="card-body">
                    <div class="row">
                        {% for championship in country.list %}
                        <div class="col-md-6 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">{{ championship.league.name }}</h5>
                                    <h6 class="card-subtitle mb-2 text-muted">{{ championship.season.name }}</h6>
                                    <p class="small">Division {{ championship.league.level }}</p>
                                    <p class="card-text">
                                        Status: {{ championship.get_status_display }}<br>
                                        Teams: {{ championship.teams.count }}/{{ championship.league.max_teams }}
                                    </p>
                                    {% if championship.teams.count > 0 %}
                                    <small class="text-muted">Teams:</small>
                                    <div class="mt-2 small">
                                        {% for team in championship.teams.all|slice:":5" %}
                                        <a href="{% url 'clubs:club_detail' team.id %}" class="text-decoration-none">
                                            {{ team.name }}{% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if championship.teams.count > 5 %}
                                        <span class="text-muted">and {{ championship.teams.count|add:"-5" }} more...</span>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                <div class="card-footer bg-transparent">
                                    <a href="{% url 'tournaments:championship_detail' championship.pk %}" 
                                       class="btn btn-primary btn-sm">View Details</a>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            {% empty %}
            <div class="alert alert-info">
                No championships available.
            </div>
            {% endfor %}
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\championship_list.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\league_list.html ---

{% extends 'tournaments/base.html' %}
{% block tournament_content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2>Leagues</h2>
            {% if user.is_staff %}
            <a href="{% url 'admin:tournaments_league_add' %}" class="btn btn-primary">
                Create New League
            </a>
            {% endif %}
        </div>

        {% for country, leagues in countries.items %}
        <div class="card mb-4">
            <div class="card-header">
                <h3 class="h5 mb-0">{{ country.name }}</h3>
            </div>
            <div class="card-body">
                <div class="row">
                    {% for league in leagues %}
                    <div class="col-md-6 mb-3">
                        <div class="card h-100">
                            <div class="card-body">
                                <h4 class="h5 card-title">{{ league.name }}</h4>
                                <p class="text-muted small mb-3">Division {{ league.level }}</p>
                                
                                <div class="mb-3">
                                    <strong>League Info:</strong>
                                    <ul class="list-unstyled mt-2">
                                        <li><i class="bi bi-people"></i> Teams: {{ league.clubs.count }}/{{ league.max_teams }}</li>
                                        <li><i class="bi bi-globe"></i> Foreign Players Limit: {{ league.foreign_players_limit }}</li>
                                        {% with championship_count=league.championship_set.count %}
                                        <li><i class="bi bi-trophy"></i> Championships: {{ championship_count }}</li>
                                        {% endwith %}
                                    </ul>
                                </div>

                                {% if league.clubs.exists %}
                                <div class="mb-3">
                                    <strong>Current Teams:</strong>
                                    <div class="mt-2 small">
                                        {% for club in league.clubs.all|slice:":5" %}
                                        <a href="{% url 'clubs:club_detail' club.id %}" class="text-decoration-none">
                                            {{ club.name }}
                                            {% if club.is_bot %}<small>(Bot)</small>{% endif %}
                                            {% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if league.clubs.count > 5 %}
                                        <span class="text-muted">and {{ league.clubs.count|add:"-5" }} more...</span>
                                        {% endif %}
                                    </div>
                                </div>
                                {% endif %}

                                {% if league.championship_set.exists %}
                                <div class="mb-3">
                                    <strong>Current Season:</strong>
                                    {% with current_championship=league.championship_set.filter.first %}
                                    <p class="small mt-2 mb-0">
                                        {{ current_championship.season.name }}
                                        ({{ current_championship.get_status_display }})
                                    </p>
                                    {% endwith %}
                                </div>
                                {% endif %}
                            </div>
                            <div class="card-footer bg-transparent">
                                <div class="btn-group w-100">
                                    {% if league.championship_set.exists %}
                                    <a href="{% url 'tournaments:championship_detail' league.championship_set.first.id %}" 
                                       class="btn btn-outline-primary">View Current Season</a>
                                    {% endif %}
                                    {% if user.is_staff %}
                                    <a href="{% url 'admin:tournaments_league_change' league.id %}" 
                                       class="btn btn-outline-secondary">Edit</a>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
        {% empty %}
        <div class="alert alert-info">
            No leagues available yet.
            {% if user.is_staff %}
            <a href="{% url 'admin:tournaments_league_add' %}" class="alert-link">Create one</a>
            {% endif %}
        </div>
        {% endfor %}
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\league_list.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\my_championship.html ---

{% extends 'tournaments/base.html' %}

{% block tournament_content %}
<div class="row">
    <!-- Header Section -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h2>{{ championship.league.name }}</h2>
                        <p class="text-muted mb-0">
                            {{ championship.league.country.name }} - Division {{ championship.league.level }}
                        </p>
                        <p class="text-muted">
                            Season: {{ championship.season.name }} | 
                            Status: {{ championship.get_status_display }}
                        </p>
                    </div>
                    <div>
                        <a href="{% url 'tournaments:championship_list' %}" class="btn btn-outline-primary">
                            View All Championships
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- League Table -->
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">League Table</h3>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-hover">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Team</th>
                                <th>MP</th>
                                <th>W</th>
                                <th>D</th>
                                <th>L</th>
                                <th>GF</th>
                                <th>GA</th>
                                <th>GD</th>
                                <th>Pts</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for team in standings %}
                            <tr {% if team.team == user.club %}class="table-active"{% endif %}>
                                <td>{{ forloop.counter }}</td>
                                <td>
                                    {{ team.team.name }}
                                    {% if team.team == user.club %}
                                        <span class="badge bg-primary">Your Club</span>
                                    {% endif %}
                                </td>
                                <td>{{ team.matches_played }}</td>
                                <td>{{ team.wins }}</td>
                                <td>{{ team.draws }}</td>
                                <td>{{ team.losses }}</td>
                                <td>{{ team.goals_for }}</td>
                                <td>{{ team.goals_against }}</td>
                                <td>{% if team.goals_difference > 0 %}+{% endif %}{{ team.goals_difference }}</td>
                                <td><strong>{{ team.points }}</strong></td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Matches -->
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h3 class="card-title h5 mb-0">Your Team's Matches</h3>
            </div>
            <div class="card-body">
                <div class="list-group">
                    {% for match in team_matches %}
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between align-items-center">
                            <small>
                                Round {{ match.round }} | {{ match.match.datetime|date:"d M H:i" }}
                            </small>
                            <span class="badge {% if match.match.status == 'finished' %}bg-success{% elif match.match.status == 'in_progress' %}bg-warning{% else %}bg-secondary{% endif %}">
                                {{ match.match.get_status_display }}
                            </span>
                        </div>
                        <div class="d-flex justify-content-between align-items-center mt-2">
                            <span {% if match.match.home_team == user.club %}class="fw-bold"{% endif %}>
                                {{ match.match.home_team.name }}
                            </span>
                            {% if match.match.status == 'finished' %}
                                <strong>{{ match.match.home_score }} - {{ match.match.away_score }}</strong>
                            {% else %}
                                <span>vs</span>
                            {% endif %}
                            <span {% if match.match.away_team == user.club %}class="fw-bold"{% endif %}>
                                {{ match.match.away_team.name }}
                            </span>
                        </div>
                    </div>
                    {% empty %}
                    <div class="alert alert-warning">
                        No matches found for your team.
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\my_championship.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\season_list.html ---

{% extends 'tournaments/base.html' %}
{% block tournament_content %}
<div class="row">
    <div class="col-12">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h2>Seasons</h2>
            {% if user.is_staff %}
            <a href="{% url 'admin:tournaments_season_add' %}" class="btn btn-primary">
                Create New Season
            </a>
            {% endif %}
        </div>

        <div class="row">
            {% for season in seasons %}
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            {{ season.name }}
                            {% if season.is_active %}
                            <span class="badge bg-success">Active</span>
                            {% endif %}
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <strong>Season Info:</strong>
                            <ul class="list-unstyled mt-2">
                                <li><i class="bi bi-calendar"></i> Start Date: {{ season.start_date }}</li>
                                <li><i class="bi bi-calendar"></i> End Date: {{ season.end_date }}</li>
                                {% with championship_count=season.championship_set.count %}
                                <li><i class="bi bi-trophy"></i> Championships: {{ championship_count }}</li>
                                {% endwith %}
                            </ul>
                        </div>

                        {% if season.championship_set.exists %}
                        <div class="mb-3">
                            <strong>Active Championships:</strong>
                            <div class="list-group mt-2">
                                {% for championship in season.championship_set.all %}
                                <div class="list-group-item">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <div>
                                            <strong>{{ championship.league.name }}</strong>
                                            <small class="text-muted">(Division {{ championship.league.level }})</small>
                                        </div>
                                        <a href="{% url 'tournaments:championship_detail' championship.id %}" 
                                           class="btn btn-sm btn-outline-primary">View</a>
                                    </div>
                                    {% if championship.teams.exists %}
                                    <div class="small mt-2">
                                        <strong>Teams:</strong>
                                        {% for team in championship.teams.all|slice:":3" %}
                                        <a href="{% url 'clubs:club_detail' team.id %}" class="text-decoration-none">
                                            {{ team.name }}{% if not forloop.last %}, {% endif %}
                                        </a>
                                        {% endfor %}
                                        {% if championship.teams.count > 3 %}
                                        <span class="text-muted">and {{ championship.teams.count|add:"-3" }} more...</span>
                                        {% endif %}
                                    </div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}
                    </div>
                    <div class="card-footer bg-transparent">
                        <div class="btn-group w-100">
                            {% if user.is_staff %}
                            <a href="{% url 'admin:tournaments_season_change' season.id %}" 
                               class="btn btn-outline-secondary">Edit</a>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
            {% empty %}
            <div class="col-12">
                <div class="alert alert-info">
                    No seasons available yet.
                    {% if user.is_staff %}
                    <a href="{% url 'admin:tournaments_season_add' %}" class="alert-link">Create one</a>
                    {% endif %}
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
</div>
{% endblock %}

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\season_list.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\templates\tournaments\timezone_selector.html ---

<form method="post" action="{% url 'tournaments:set_timezone' %}" class="timezone-form">
    {% csrf_token %}
    <input type="hidden" name="next" value="{{ request.path }}">
    <select name="timezone" class="form-select form-select-sm" onchange="this.form.submit()">
        {% for tz, name in TOURNAMENT_TIMEZONES %}
            <option value="{{ tz }}" {% if tz == user_timezone %}selected{% endif %}>
                {{ name }}
            </option>
        {% endfor %}
    </select>
</form>

# --- ????? ????? C:\realfootballsim\tournaments\templates\tournaments\timezone_selector.html ---


# --- ?????? ????? C:\realfootballsim\tournaments\tests\test_championships.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\tests\test_season_transitions.py ---

from django.test import TestCase
from django.utils import timezone
from django.core.management import call_command
from tournaments.models import Season, League, Championship, ChampionshipTeam
from tournaments.tasks import check_season_end
from clubs.models import Club
from datetime import timedelta
from django.db import transaction

class SeasonTransitionTests(TestCase):
    def setUp(self):
        """
        Настройка тестового окружения.
        Создаём сезон, лиги, команды и чемпионаты
        """
        # Создаем сезон
        self.season = Season.objects.create(
            number=1,
            name="Test Season",
            start_date=timezone.now().date(),
            end_date=timezone.now().date() + timedelta(days=30),
            is_active=True
        )

        # Создаем две лиги для одной страны
        self.league_div1 = League.objects.create(
            name="Test League D1",
            country='GB',
            level=1,
            max_teams=16
        )
        
        self.league_div2 = League.objects.create(
            name="Test League D2",
            country='GB',
            level=2,
            max_teams=16
        )

        # Создаем команды для обоих дивизионов
        self.div1_teams = []
        self.div2_teams = []

        with transaction.atomic():
            # Создаём команды первого дивизиона
            for i in range(16):
                team = Club.objects.create(
                    name=f"D1 Team {i+1}",
                    country='GB',
                    league=self.league_div1,
                    is_bot=True
                )
                self.div1_teams.append(team)

            # Создаём команды второго дивизиона
            for i in range(16):
                team = Club.objects.create(
                    name=f"D2 Team {i+1}",
                    country='GB',
                    league=self.league_div2,
                    is_bot=True
                )
                self.div2_teams.append(team)

            # Создаем чемпионаты
            self.championship_div1 = Championship.objects.create(
                season=self.season,
                league=self.league_div1,
                status='in_progress',
                start_date=self.season.start_date,
                end_date=self.season.end_date
            )

            self.championship_div2 = Championship.objects.create(
                season=self.season,
                league=self.league_div2,
                status='in_progress',
                start_date=self.season.start_date,
                end_date=self.season.end_date
            )

            # Добавляем команды в чемпионат первого дивизиона
            for team in self.div1_teams:
                self.championship_div1.teams.add(team)
                ChampionshipTeam.objects.filter(
                    championship=self.championship_div1,
                    team=team
                ).update(
                    points=0,
                    matches_played=0,
                    wins=0,
                    draws=0,
                    losses=0,
                    goals_for=0,
                    goals_against=0
                )

            # Добавляем команды в чемпионат второго дивизиона
            for team in self.div2_teams:
                self.championship_div2.teams.add(team)
                ChampionshipTeam.objects.filter(
                    championship=self.championship_div2,
                    team=team
                ).update(
                    points=0,
                    matches_played=0,
                    wins=0,
                    draws=0,
                    losses=0,
                    goals_for=0,
                    goals_against=0
                )

    def test_season_transitions(self):
        """Тестируем процесс переходов между дивизионами"""
        
        # Устанавливаем результаты для команд первого дивизиона
        div1_teams = ChampionshipTeam.objects.filter(
            championship=self.championship_div1
        )
        for i, team_stats in enumerate(div1_teams):
            team_stats.points = 80 - i * 5  # От 80 до 5 очков
            team_stats.matches_played = 30
            team_stats.save()

        # Устанавливаем результаты для команд второго дивизиона
        div2_teams = ChampionshipTeam.objects.filter(
            championship=self.championship_div2
        )
        for i, team_stats in enumerate(div2_teams):
            team_stats.points = 80 - i * 5  # От 80 до 5 очков
            team_stats.matches_played = 30
            team_stats.save()

        # Завершаем сезон и запускаем переходы
        self.season.end_date = timezone.now().date() - timedelta(days=1)
        self.season.save()
        
        # Запускаем обработку переходов
        call_command('handle_season_transitions')

        # Проверяем что две худшие команды из D1 перешли в D2
        relegated_teams = div1_teams.order_by('points')[:2]
        for team_stats in relegated_teams:
            team = Club.objects.get(id=team_stats.team.id)
            self.assertEqual(
                team.league, 
                self.league_div2,
                f"Team {team.name} should be relegated to D2"
            )

        # Проверяем что две лучшие команды из D2 перешли в D1
        promoted_teams = div2_teams.order_by('-points')[:2]
        for team_stats in promoted_teams:
            team = Club.objects.get(id=team_stats.team.id)
            self.assertEqual(
                team.league, 
                self.league_div1,
                f"Team {team.name} should be promoted to D1"
            )

    def test_new_season_creation(self):
        """Тестируем создание нового сезона после переходов"""
        
        # Завершаем текущий сезон
        self.season.end_date = timezone.now().date() - timedelta(days=1)
        self.season.save()
        
        # Запускаем процесс создания нового сезона
        call_command('create_new_season')

        # Проверяем что новый сезон создан
        new_season = Season.objects.get(number=self.season.number + 1)
        self.assertTrue(new_season.is_active)
        
        # Проверяем что созданы чемпионаты
        new_championships = Championship.objects.filter(season=new_season)
        self.assertEqual(new_championships.count(), 2)
        
        # Проверяем корректность распределения команд
        for championship in new_championships:
            self.assertEqual(
                championship.teams.count(), 
                16,
                f"Championship {championship} should have 16 teams"
            )

    def test_full_transition_process(self):
        """Тестируем полный процесс перехода к новому сезону"""
        
        # Завершаем текущий сезон
        self.season.end_date = timezone.now().date() - timedelta(days=1)
        self.season.save()

        # Запускаем проверку окончания сезона через Celery задачу
        check_season_end()

        # Проверяем что старый сезон неактивен
        old_season = Season.objects.get(id=self.season.id)
        self.assertFalse(old_season.is_active)

        # Проверяем что создан новый сезон
        new_season = Season.objects.get(is_active=True)
        self.assertNotEqual(new_season.id, self.season.id)

        # Проверяем корректность переходов
        # В первом дивизионе должны остаться 14 старых команд + 2 новых
        div1_championship = Championship.objects.get(
            season=new_season,
            league=self.league_div1
        )
        self.assertEqual(div1_championship.teams.count(), 16)

        # Во втором дивизионе должны остаться 14 старых команд + 2 новых
        div2_championship = Championship.objects.get(
            season=new_season,
            league=self.league_div2
        )
        self.assertEqual(div2_championship.teams.count(), 16)

    def tearDown(self):
        """Очистка после тестов"""
        Season.objects.all().delete()
        League.objects.all().delete()
        Club.objects.all().delete()

# --- ????? ????? C:\realfootballsim\tournaments\tests\test_season_transitions.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\tests\__init__.py ---


# --- ????? ????? C:\realfootballsim\tournaments\tests\__init__.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\admin.py ---

from django.contrib import admin
from django.core.management import call_command
from django.contrib import messages
from .models import Season, League, Championship, ChampionshipTeam, ChampionshipMatch

@admin.register(Season)
class SeasonAdmin(admin.ModelAdmin):
    list_display = ('number', 'name', 'start_date', 'end_date', 'is_active')
    list_filter = ('is_active',)
    search_fields = ('name',)
    ordering = ('-start_date',)
    actions = ['end_season', 'force_end_season']

    def end_season(self, request, queryset):
        if queryset.count() > 1:
            messages.error(request, "Can only end one season at a time.")
            return
        
        season = queryset.first()
        if not season.is_active:
            messages.error(request, "Can only end active season.")
            return

        try:
            call_command('end_season')
            messages.success(request, f"Successfully ended season {season.number}")
        except Exception as e:
            messages.error(request, f"Error ending season: {str(e)}")
    
    end_season.short_description = "End selected season"

    def force_end_season(self, request, queryset):
        if queryset.count() > 1:
            messages.error(request, "Can only end one season at a time.")
            return
        
        season = queryset.first()
        if not season.is_active:
            messages.error(request, "Can only end active season.")
            return

        try:
            call_command('end_season', '--force')
            messages.success(
                request, 
                f"Successfully force ended season {season.number}"
            )
        except Exception as e:
            messages.error(request, f"Error force ending season: {str(e)}")
    
    force_end_season.short_description = "Force end selected season (skip validations)"

@admin.register(League)
class LeagueAdmin(admin.ModelAdmin):
    list_display = ('name', 'country', 'level', 'max_teams')
    list_filter = ('country', 'level')
    search_fields = ('name',)
    ordering = ['country', 'level']

class ChampionshipTeamInline(admin.TabularInline):
    model = ChampionshipTeam
    extra = 0
    fields = (
        'team', 'points', 'matches_played', 
        'wins', 'draws', 'losses', 
        'goals_for', 'goals_against', 'goals_difference'
    )
    readonly_fields = (
        'points', 'matches_played', 
        'wins', 'draws', 'losses', 
        'goals_for', 'goals_against', 'goals_difference'
    )
    ordering = ('-points', '-goals_for')
    can_delete = False

    def has_add_permission(self, request, obj=None):
        return False

class ChampionshipMatchInline(admin.TabularInline):
    model = ChampionshipMatch
    extra = 0
    fields = ('match', 'round', 'match_day', 'processed')
    readonly_fields = ('processed',)

@admin.register(Championship)
class ChampionshipAdmin(admin.ModelAdmin):
    list_display = (
        'league', 'season', 'status', 'start_date', 
        'end_date', 'total_matches', 'finished_matches'
    )
    list_filter = ('status', 'season', 'league')
    search_fields = ('league__name', 'season__name')
    inlines = [ChampionshipTeamInline, ChampionshipMatchInline]
    
    def get_readonly_fields(self, request, obj=None):
        if obj and obj.status != 'pending':
            return ['season', 'league', 'start_date']
        return []

    def total_matches(self, obj):
        return obj.championshipmatch_set.count()
    total_matches.short_description = "Total Matches"

    def finished_matches(self, obj):
        return obj.championshipmatch_set.filter(
            match__status='finished'
        ).count()
    finished_matches.short_description = "Finished Matches"

@admin.register(ChampionshipTeam)
class ChampionshipTeamAdmin(admin.ModelAdmin):
    list_display = (
        'team', 'championship', 'points', 
        'matches_played', 'wins', 'draws', 
        'losses', 'goals_for', 'goals_against', 
        'goals_difference'
    )
    list_filter = ('championship',)
    search_fields = ('team__name', 'championship__league__name')
    readonly_fields = (
        'points', 'matches_played', 'wins', 
        'draws', 'losses', 'goals_for', 
        'goals_against', 'goals_difference'
    )
    ordering = ('-points', '-goals_for')

@admin.register(ChampionshipMatch)
class ChampionshipMatchAdmin(admin.ModelAdmin):
    list_display = (
        'match', 'championship', 'round', 
        'match_day', 'status', 'score'
    )
    list_filter = ('championship', 'round', 'match__status')
    search_fields = (
        'match__home_team__name', 
        'match__away_team__name'
    )
    readonly_fields = ('processed',)

    def status(self, obj):
        return obj.match.get_status_display()
    status.short_description = "Status"

    def score(self, obj):
        if obj.match.status == 'finished':
            return f"{obj.match.home_score} - {obj.match.away_score}"
        return "-"
    score.short_description = "Score"

# --- ????? ????? C:\realfootballsim\tournaments\admin.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\apps.py ---

from django.apps import AppConfig

class TournamentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'tournaments'
    verbose_name = 'Tournaments Management'

    def ready(self):
        import tournaments.signals

# --- ????? ????? C:\realfootballsim\tournaments\apps.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\context_processors.py ---

from django.conf import settings

def timezone_context(request):
    return {
        'TOURNAMENT_TIMEZONES': settings.TOURNAMENT_TIMEZONES,
        'user_timezone': request.session.get('django_timezone', 'UTC')
    }

# --- ????? ????? C:\realfootballsim\tournaments\context_processors.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\date_utils.py ---

import calendar
from datetime import date
from django.utils import timezone

def get_next_season_dates():
    """
    Вычисляет даты начала и конца следующего сезона.
    Использует реальное количество дней в каждом месяце.
    Возвращает кортеж (start_date, end_date).
    """
    today = timezone.now().date()
    
    # Определяем начало сезона - первое число следующего месяца
    if today.day != 1:
        year = today.year
        month = today.month
        if month == 12:
            month = 1
            year += 1
        else:
            month += 1
        start_date = date(year, month, 1)
    else:
        # Если сегодня 1 число, начинаем сезон сегодня
        start_date = today

    # Определяем последний день месяца используя calendar.monthrange
    _, last_day = calendar.monthrange(start_date.year, start_date.month)
    end_date = start_date.replace(day=last_day)
    
    return start_date, end_date

# --- ????? ????? C:\realfootballsim\tournaments\date_utils.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\middleware.py ---

# tournaments/middleware.py
from django.utils import timezone
from datetime import timedelta
from matches.models import Match
from matches.match_simulation import simulate_match
import logging

logger = logging.getLogger('matches')

class MatchSimulationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.last_check = timezone.now()
        self.check_interval = timedelta(seconds=10)  # Уменьшим интервал для тестирования
        logger.info("Match simulation middleware initialized")

    def __call__(self, request):
        now = timezone.now()
        
        # Добавим подробное логирование
        logger.info(f"Checking matches at {now}")
        logger.info(f"Last check was at {self.last_check}")
        
        if now - self.last_check >= self.check_interval:
            logger.info("Starting match check...")
            self.check_matches()
            self.last_check = now
            
        return self.get_response(request)

    def check_matches(self):
        now = timezone.now()
        matches = Match.objects.filter(
            status='scheduled',
            date__lte=now
        ).select_related('home_team', 'away_team')

        logger.info(f"Found {matches.count()} matches to check")
        
        for match in matches:
            try:
                logger.info(f"Simulating match: {match.home_team} vs {match.away_team}")
                simulate_match(match.id)
                
                # Перезагружаем матч для получения результата
                match.refresh_from_db()
                logger.info(
                    f"Match simulated: {match.home_team} {match.home_score} - {match.away_score} {match.away_team}"
                )
            except Exception as e:
                logger.error(f"Error simulating match {match.id}: {str(e)}")

# --- ????? ????? C:\realfootballsim\tournaments\middleware.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\models.py ---

from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone
from django_countries.fields import CountryField
from clubs.models import Club
from matches.models import Match
from datetime import datetime, timedelta, time
import pytz
import calendar
from .date_utils import get_next_season_dates  # Изменен импорт

class Season(models.Model):
    """Model for representing a game season"""
    number = models.PositiveIntegerField(
        unique=True, 
        help_text="Порядковый номер сезона"
    )
    name = models.CharField(max_length=100)
    start_date = models.DateField()
    end_date = models.DateField()
    is_active = models.BooleanField(default=False)

    class Meta:
        ordering = ['-start_date']

    def __str__(self):
        return f"Сезон {self.number} ({self.start_date.strftime('%B %Y')})"

    def clean(self):
        """Проверка корректности дат сезона"""
        if not self.start_date:
            return

        if self.start_date.day != 1:
            raise ValidationError({
                'start_date': 'Дата начала сезона должна быть первым числом месяца'
            })

        # Определяем последний день месяца используя calendar.monthrange
        _, last_day = calendar.monthrange(self.start_date.year, self.start_date.month)
        expected_end_date = self.start_date.replace(day=last_day)
        
        if self.end_date != expected_end_date:
            raise ValidationError({
                'end_date': f'Дата окончания сезона должна быть {last_day}-м числом месяца'
            })

    @property
    def is_february(self) -> bool:
        """Проверяет, является ли текущий сезон февральским"""
        return self.start_date.month == 2

    @property
    def needs_double_matchday(self) -> bool:
        """Определяет, нужны ли двойные туры в этом сезоне"""
        return self.is_february and calendar.monthrange(self.start_date.year, 2)[1] == 28

    def get_double_matchday_dates(self) -> list:
        """Возвращает даты для двойных туров"""
        if not self.needs_double_matchday:
            return []
        
        dates = [self.start_date.replace(day=15)]
        if self.end_date.day == 28:  # Для невисокосного февраля
            dates.append(self.start_date.replace(day=16))
        return dates

    def save(self, *args, **kwargs):
        if not self.name:
            self.name = f"Сезон {self.number}"
        super().save(*args, **kwargs)

    @classmethod
    def create_next_season(cls) -> 'Season':
        """Создает новый сезон"""
        last_season = cls.objects.order_by('-number').first()
        new_season_number = 1 if not last_season else last_season.number + 1

        # Получаем даты следующего сезона
        start_date, end_date = get_next_season_dates()

        season = cls(
            number=new_season_number,
            start_date=start_date,
            end_date=end_date,
            is_active=True
        )
        season.full_clean()
        season.save()
        return season

class League(models.Model):
    """Model for representing a league/division"""
    name = models.CharField(max_length=100)
    country = CountryField()
    level = models.PositiveIntegerField()  # 1 for top division, 2 for second, etc.
    max_teams = models.PositiveIntegerField(default=16)
    foreign_players_limit = models.PositiveIntegerField(
        default=5, 
        help_text="Maximum number of foreign players allowed in match squad"
    )

    class Meta:
        unique_together = ['country', 'level']
        ordering = ['country', 'level']

    def __str__(self):
        return f"{self.name} ({self.country})"

    def clean(self):
        if self.max_teams != 16:
            raise ValidationError({
                'max_teams': 'Количество команд в лиге должно быть равно 16'
            })

class Championship(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('finished', 'Finished')
    ]

    season = models.ForeignKey(Season, on_delete=models.CASCADE)
    league = models.ForeignKey(League, on_delete=models.CASCADE)
    teams = models.ManyToManyField(Club, through='ChampionshipTeam')
    status = models.CharField(
        max_length=20, 
        choices=STATUS_CHOICES,
        default='pending'
    )
    start_date = models.DateField()
    end_date = models.DateField()
    match_time = models.TimeField(
        default=time(18, 0),
        help_text="Match start time (UTC)"
    )

    class Meta:
        unique_together = ['season', 'league']

    def __str__(self):
        return f"{self.league.name} - {self.season.name}"

    def get_local_match_time(self, user_timezone=None):
        if not user_timezone:
            user_timezone = timezone.get_current_timezone()
        utc_time = datetime.combine(datetime.today(), self.match_time)
        utc_time = pytz.utc.localize(utc_time)
        return utc_time.astimezone(user_timezone).time()

    def clean(self):
        if self.teams.count() != 16:
            raise ValidationError('Количество команд в чемпионате должно быть равно 16')

    def can_participate_in_transitions(self) -> bool:
        """Проверяет, может ли чемпионат участвовать в переходах"""
        if not self.is_completed:
            return False
            
        valid, error = self.validate_status()
        if not valid:
            return False
            
        if self.league.level not in [1, 2]:
            return False
            
        return True

    def get_teams_for_relegation(self) -> list:
        """Возвращает две команды для понижения в дивизионе"""
        if self.league.level != 1:
            raise ValidationError("Relegation is only possible from the first division")

        if not self.can_participate_in_transitions():
            raise ValidationError("Championship cannot participate in transitions yet")
            
        return (
            self.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .select_related('team')
            .order_by(
                'points',
                'goals_diff',
                'goals_for'
            )[:2]
        )

    def get_teams_for_promotion(self) -> list:
        """Возвращает две команды для повышения в дивизионе"""
        if self.league.level != 2:
            raise ValidationError("Promotion is only possible from the second division")

        if not self.can_participate_in_transitions():
            raise ValidationError("Championship cannot participate in transitions yet")
            
        return (
            self.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .select_related('team')
            .order_by(
                '-points',
                '-goals_diff',
                '-goals_for'
            )[:2]
        )

    @property
    def is_completed(self) -> bool:
        """Проверяет, завершены ли все матчи чемпионата"""
        return not self.championshipmatch_set.filter(
            ~models.Q(match__status='finished')
        ).exists()

    def get_standings(self) -> list:
        """Возвращает отсортированную таблицу результатов"""
        return (
            self.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .select_related('team')
            .order_by(
                '-points',
                '-goals_diff',
                '-goals_for'
            )
        )

    def validate_status(self) -> tuple:
        """
        Проверяет текущий статус чемпионата
        Возвращает (is_valid, error_message)
        """
        if self.teams.count() != 16:
            return False, "Неверное количество команд в чемпионате"
                
        matches_count = self.championshipmatch_set.count()
        expected_matches = 16 * 15  # Каждая команда играет с каждой другой дважды
        if matches_count != expected_matches:
            return False, f"Неверное количество матчей: {matches_count} вместо {expected_matches}"
                
        return True, None

class ChampionshipTeam(models.Model):
    """Model for storing team statistics in championship"""
    championship = models.ForeignKey(Championship, on_delete=models.CASCADE)
    team = models.ForeignKey(Club, on_delete=models.CASCADE)
    points = models.PositiveIntegerField(default=0)
    matches_played = models.PositiveIntegerField(default=0)
    wins = models.PositiveIntegerField(default=0)
    draws = models.PositiveIntegerField(default=0)
    losses = models.PositiveIntegerField(default=0)
    goals_for = models.PositiveIntegerField(default=0)
    goals_against = models.PositiveIntegerField(default=0)

    class Meta:
        unique_together = ['championship', 'team']
        ordering = ['-points', '-goals_for']

    def __str__(self):
        return f"{self.team.name} - {self.championship}"

    @property
    def goals_difference(self):
        """Calculate goals difference"""
        return self.goals_for - self.goals_against

    @property
    def points_per_game(self):
        """Calculate average points per game"""
        if self.matches_played > 0:
            return round(self.points / self.matches_played, 2)
        return 0

    @property
    def position(self) -> int:
        """Возвращает текущую позицию команды в таблице"""
        return (
            self.championship.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .filter(
                models.Q(points__gt=self.points) |
                (models.Q(points=self.points) & models.Q(goals_diff__gt=self.goals_difference)) |
                (models.Q(points=self.points) & 
                 models.Q(goals_diff=self.goals_difference) & 
                 models.Q(goals_for__gt=self.goals_for))
            )
            .count() + 1
        )

    @property
    def is_relegation_zone(self) -> bool:
        """Проверяет, находится ли команда в зоне вылета"""
        return self.position >= 15

    @property
    def is_promotion_zone(self) -> bool:
        """Проверяет, находится ли команда в зоне повышения"""
        return self.position <= 2

class ChampionshipMatch(models.Model):
    """Model for linking matches to championship"""
    championship = models.ForeignKey(Championship, on_delete=models.CASCADE)
    match = models.OneToOneField(Match, on_delete=models.CASCADE)
    round = models.PositiveIntegerField()
    match_day = models.PositiveIntegerField()
    processed = models.BooleanField(default=False)

    class Meta:
        ordering = ['round', 'match_day']

    def __str__(self):
        return f"Round {self.round}: {self.match}"

    @property
    def match_datetime(self):
        """Возвращает дату и время матча"""
        return datetime.combine(
            self.championship.start_date + timedelta(days=self.match_day - 1),
            datetime.min.time().replace(hour=18)
        )

# --- ????? ????? C:\realfootballsim\tournaments\models.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\signals.py ---

from django.db.models.signals import post_save, pre_save
from django.dispatch import receiver
from clubs.models import Club
from tournaments.models import Championship, ChampionshipTeam, ChampionshipMatch, Season
from matches.models import Match
from django.db import transaction
from django.db.models import Q
from django.core.management import call_command

def update_matches_for_replaced_team(championship, old_team_id, new_team):
    """
    Обновляет все матчи, заменяя old_team на new_team
    """
    try:
        with transaction.atomic():
            # Находим все матчи старой команды
            bot_matches = Match.objects.filter(
                championshipmatch__championship=championship
            ).filter(
                Q(home_team_id=old_team_id) | Q(away_team_id=old_team_id)
            ).select_related(
                'championshipmatch',
                'home_team',
                'away_team'
            ).order_by('championshipmatch__round')

            # Обновляем каждый матч
            updated_count = 0
            unique_opponents = set()

            for match in bot_matches:
                # Получаем противника
                opponent = match.away_team if match.home_team_id == old_team_id else match.home_team
                unique_opponents.add(opponent.id)
                
                # Обновляем команду в матче
                if match.home_team_id == old_team_id:
                    match.home_team = new_team
                else:
                    match.away_team = new_team

                match.save()
                updated_count += 1

            # Проверка на количество уникальных противников
            if len(unique_opponents) < 2:
                raise ValueError(
                    f"Error: team has only {len(unique_opponents)} opponents. "
                    f"Something is wrong with the schedule."
                )

            return updated_count

    except Exception as e:
        raise

@receiver(post_save, sender=Club)
def handle_club_creation(sender, instance, created, **kwargs):
    """Обрабатывает создание нового клуба и замещение бота"""
    if not created or instance.is_bot:
        return
        
    try:
        with transaction.atomic():
            # Найти активный чемпионат
            championship = Championship.objects.select_related('season')\
                .filter(
                    league__country=instance.country,
                    league__level=1,
                    season__is_active=True
                ).first()
                
            if not championship:
                return

            # Проверяем, не добавлен ли уже клуб
            if championship.teams.filter(id=instance.id).exists():
                return
                
            # Найти команду-бота для замены
            bot_team = championship.teams.filter(is_bot=True).first()
            if not bot_team:
                return
            
            # Сохраняем ID бота перед удалением
            bot_team_id = bot_team.id
                
            # Получаем статистику бота
            bot_stats = ChampionshipTeam.objects.get(
                championship=championship,
                team=bot_team
            )
            
            # Создаем запись для нового клуба
            ChampionshipTeam.objects.create(
                championship=championship,
                team=instance,
                points=bot_stats.points,
                matches_played=bot_stats.matches_played,
                wins=bot_stats.wins,
                draws=bot_stats.draws,
                losses=bot_stats.losses,
                goals_for=bot_stats.goals_for,
                goals_against=bot_stats.goals_against
            )
            
            # Обновляем матчи
            update_matches_for_replaced_team(
                championship=championship,
                old_team_id=bot_team_id,
                new_team=instance
            )
            
            # Удаляем бота
            bot_stats.delete()
            bot_team.delete()
            
    except Exception as e:
        raise

@receiver(post_save, sender=Match)
def handle_match_result(sender, instance, **kwargs):
    """Обновляет статистику команд после завершения матча"""
    try:
        championship_match = ChampionshipMatch.objects.select_related(
            'championship',
            'match',
            'match__home_team',
            'match__away_team'
        ).filter(match=instance).first()

        if not championship_match or championship_match.processed or instance.status != 'finished':
            return

        max_attempts = 3
        current_attempt = 0

        while current_attempt < max_attempts:
            try:
                with transaction.atomic():
                    # Получаем статистику команд
                    home_stats = ChampionshipTeam.objects.select_for_update().get(
                        championship=championship_match.championship,
                        team=instance.home_team
                    )
                    away_stats = ChampionshipTeam.objects.select_for_update().get(
                        championship=championship_match.championship,
                        team=instance.away_team
                    )

                    # Обновляем статистику
                    home_stats.matches_played += 1
                    away_stats.matches_played += 1
                    home_stats.goals_for += instance.home_score
                    home_stats.goals_against += instance.away_score
                    away_stats.goals_for += instance.away_score
                    away_stats.goals_against += instance.home_score

                    # Обновляем результаты
                    if instance.home_score > instance.away_score:
                        home_stats.wins += 1
                        home_stats.points += 3
                        away_stats.losses += 1
                    elif instance.home_score < instance.away_score:
                        away_stats.wins += 1
                        away_stats.points += 3
                        home_stats.losses += 1
                    else:
                        home_stats.draws += 1
                        away_stats.draws += 1
                        home_stats.points += 1
                        away_stats.points += 1

                    # Сохраняем изменения
                    home_stats.save()
                    away_stats.save()

                    # Проверяем завершение чемпионата
                    championship = championship_match.championship
                    if championship.is_completed and championship.status != 'finished':
                        championship.status = 'finished'
                        championship.save()

                    championship_match.processed = True
                    championship_match.save()
                    return

            except Exception:
                current_attempt += 1
                if current_attempt == max_attempts:
                    raise
                import time
                time.sleep(1)

    except Exception:
        raise

@receiver(post_save, sender=Season)
def handle_season_end(sender, instance, **kwargs):
    """Обрабатывает окончание сезона"""
    # Проверяем, что сезон был активным, но стал неактивным
    if not instance.is_active and kwargs.get('update_fields') and 'is_active' in kwargs['update_fields']:
        try:
            with transaction.atomic():
                # Запускаем процесс переходов между дивизионами
                call_command('handle_season_transitions')
        except Exception as e:
            raise

@receiver(post_save, sender=ChampionshipTeam)
def update_team_league(sender, instance, **kwargs):
    """Обновляет привязку команды к лиге при изменении статистики"""
    if instance.championship.status == 'finished':
        try:
            with transaction.atomic():
                team = instance.team
                
                # Получаем текущую позицию команды
                position = instance.position
                current_level = instance.championship.league.level
                
                # Определяем, нужно ли менять лигу
                if current_level == 1 and position >= 15:  # Вылет из высшего дивизиона
                    new_league = League.objects.get(
                        country=team.country,
                        level=2
                    )
                    team.league = new_league
                    team.save()
                elif current_level == 2 and position <= 2:  # Повышение во второй дивизион
                    new_league = League.objects.get(
                        country=team.country,
                        level=1
                    )
                    team.league = new_league
                    team.save()
        except Exception as e:
            raise

# --- ????? ????? C:\realfootballsim\tournaments\signals.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\tasks.py ---

from celery import shared_task
from django.utils import timezone
from django.db import transaction, OperationalError
from django.core.management import call_command
from matches.models import Match
from matches.match_simulation import simulate_match
from django.db import models
from .models import Season, Championship, League
import logging
from datetime import timedelta
import time
from django.core.exceptions import ObjectDoesNotExist

logger = logging.getLogger(__name__)

def retry_on_db_lock(func, max_attempts=3, delay=1):
    def wrapper(*args, **kwargs):
        attempts = 0
        while attempts < max_attempts:
            try:
                return func(*args, **kwargs)
            except OperationalError as e:
                if "database is locked" in str(e) and attempts < max_attempts - 1:
                    attempts += 1
                    time.sleep(delay)
                    continue
                raise
    return wrapper

@shared_task(
    name='tournaments.check_and_simulate_matches',
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={'max_retries': 3, 'countdown': 60}
)
def check_and_simulate_matches(self):
    """
    Проверяет и симулирует все несыгранные матчи в хронологическом порядке.
    """
    try:
        now = timezone.now()
        logger.info(f"Starting match check at {now}")
        
        if not Season.objects.filter(is_active=True).exists():
            logger.warning("No active season found, skipping match simulation")
            return "No active season found"
        
        # Определяем время для проверки матчей (18:00 текущего дня)
        today_6pm = timezone.make_aware(
            timezone.datetime.combine(
                now.date(),
                timezone.datetime.strptime("18:00", "%H:%M").time()
            )
        )
        
        # Получаем все несыгранные матчи до текущего момента
        matches = Match.objects.filter(
            status='scheduled',
            datetime__lte=today_6pm,  # Все матчи до 18:00 текущего дня
            championshipmatch__isnull=False,
            processed=False
        ).select_related(
            'home_team', 
            'away_team',
            'championshipmatch',
            'championshipmatch__championship',
            'championshipmatch__championship__league'
        ).order_by('datetime')  # Сортируем по времени матча
        
        if not matches.exists():
            logger.info("No matches to simulate")
            return "No matches to simulate"
        
        logger.info(f"Found {matches.count()} matches to simulate")
        
        simulated_count = {'div1': 0, 'div2': 0}
        errors_count = 0
        
        @retry_on_db_lock
        def simulate_match_with_retry(match_id):
            with transaction.atomic():
                simulate_match(match_id)
        
        for match in matches:
            try:
                championship_match = match.championshipmatch
                division = championship_match.championship.league.level
                
                if not championship_match.championship.season.is_active:
                    logger.warning(f"Match {match.id} belongs to inactive season, skipping")
                    continue
                
                logger.info(
                    f"Simulating Division {division} match: "
                    f"{match.home_team} vs {match.away_team} "
                    f"(ID: {match.id}, scheduled: {match.datetime})"
                )
                
                simulate_match_with_retry(match.id)
                
                if division == 1:
                    simulated_count['div1'] += 1
                else:
                    simulated_count['div2'] += 1
                
                match.processed = True
                match.save(update_fields=['processed'])
                
                time.sleep(0.05)
                
            except ObjectDoesNotExist as e:
                logger.error(f"Match {match.id} has invalid references: {str(e)}")
                continue
                
            except Exception as e:
                errors_count += 1
                logger.error(f"Error simulating match {match.id}: {str(e)}")
                if errors_count >= 10:
                    raise Exception(f"Too many simulation errors: {str(e)}")
                continue
        
        result_message = (
            f"Simulated {sum(simulated_count.values())} matches "
            f"({simulated_count['div1']} in Div1, {simulated_count['div2']} in Div2)"
        )
        if errors_count > 0:
            result_message += f" with {errors_count} errors"
            
        logger.info(result_message)
        return result_message
        
    except Exception as e:
        logger.error(f"Task failed: {str(e)}")
        raise

@shared_task(
    name='tournaments.check_season_end',
    bind=True,
    autoretry_for=(Exception,),
    retry_kwargs={'max_retries': 3, 'countdown': 60}
)
def check_season_end(self):
    """Проверяет окончание сезона и запускает необходимые процессы"""
    try:
        with transaction.atomic():
            current_season = Season.objects.select_for_update().get(is_active=True)
            today = timezone.now().date()
            
            logger.info(f"Checking season {current_season.number} (end date: {current_season.end_date})")
            
            # Проверяем оба условия: конец месяца и все матчи сыграны
            is_end_date_passed = today > current_season.end_date
            
            finished_matches_count = Match.objects.filter(
                championshipmatch__championship__season=current_season,
                status='finished'
            ).count()

            required_matches = len(Championship.objects.filter(season=current_season)) * (16 * 15)  # Количество команд * количество матчей
            all_matches_played = finished_matches_count >= required_matches

            # Сезон заканчивается только если оба условия выполнены
            if is_end_date_passed and all_matches_played:
                logger.info(f"Season {current_season.number} has ended. Starting end-season process...")
                
                unfinished_matches = Match.objects.filter(
                    championshipmatch__championship__season=current_season,
                    status__in=['scheduled', 'in_progress']
                )
                
                unfinished_count = unfinished_matches.count()
                if unfinished_count > 0:
                    logger.warning(
                        f"Found {unfinished_count} unfinished matches. "
                        "Season cannot end with unfinished matches."
                    )
                    return (f"Season {current_season.number} has "
                           f"{unfinished_count} unfinished matches")
                
                logger.info("Processing teams transitions between divisions...")
                call_command('handle_season_transitions')
                
                current_season.is_active = False
                current_season.save()
                logger.info(f"Deactivated season {current_season.number}")
                
                logger.info("Creating new season...")
                call_command('create_new_season')
                
                try:
                    new_season = Season.objects.get(is_active=True)
                    logger.info(f"Successfully created new season {new_season.number}")
                    
                    championships = Championship.objects.filter(season=new_season)
                    total_teams = sum(c.teams.count() for c in championships)
                    
                    return (
                        f"Season {current_season.number} ended successfully. "
                        f"Created new season {new_season.number} with "
                        f"{championships.count()} championships and {total_teams} teams"
                    )
                except Season.DoesNotExist:
                    error_msg = "Failed to create new season"
                    logger.error(error_msg)
                    raise Exception(error_msg)
                except Season.MultipleObjectsReturned:
                    error_msg = "Multiple active seasons found after creation"
                    logger.error(error_msg)
                    raise Exception(error_msg)
            
            if not all_matches_played:
                return f"Season {current_season.number} is waiting for matches completion ({finished_matches_count}/{required_matches})"
            if not is_end_date_passed:
                return f"Season {current_season.number} is still active until {current_season.end_date}"
            return f"Season {current_season.number} needs both end date and all matches to end"
            
    except Season.DoesNotExist:
        logger.warning("No active season found")
        return "No active season found"
    except Exception as e:
        logger.error(f"Error in season end check: {str(e)}")
        raise

# --- ????? ????? C:\realfootballsim\tournaments\tasks.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\tests.py ---

from django.test import TestCase
from django.utils import timezone
from datetime import datetime, timedelta
from django.core.exceptions import ValidationError
from django_countries import countries
from .models import Season, League, Championship, ChampionshipTeam
from .utils import generate_league_schedule, create_championship_matches, validate_championship_schedule
from clubs.models import Club

class ChampionshipSystemTests(TestCase):
    def setUp(self):
        """Настройка тестовых данных"""
        # Создаем сезон
        self.season = Season.objects.create(
            number=1,
            start_date=datetime(2024, 3, 1).date(),
            end_date=datetime(2024, 3, 30).date(),
            is_active=True
        )

        # Создаем лигу
        self.league = League.objects.create(
            name="Test League",
            country='GB',  # Великобритания
            level=1,
            max_teams=16
        )

        # Создаем тестовые клубы
        self.clubs = []
        for i in range(16):
            club = Club.objects.create(
                name=f"Test Club {i+1}",
                country='GB',
                is_bot=True
            )
            self.clubs.append(club)

        # Создаем чемпионат
        self.championship = Championship.objects.create(
            season=self.season,
            league=self.league,
            status='pending',
            start_date=self.season.start_date,
            end_date=self.season.end_date
        )

        # Добавляем команды в чемпионат
        for club in self.clubs:
            ChampionshipTeam.objects.create(
                championship=self.championship,
                team=club
            )

    def test_schedule_generation_basic(self):
        """Тест базовой генерации расписания"""
        schedule = generate_league_schedule(self.championship)
        self.assertEqual(len(schedule), 240)  # 16 команд = 30 туров по 8 матчей

    def test_home_away_balance(self):
        """Тест баланса домашних/выездных матчей"""
        schedule = generate_league_schedule(self.championship)
        
        # Подсчет домашних и выездных матчей для каждой команды
        home_games = {club: 0 for club in self.clubs}
        away_games = {club: 0 for club in self.clubs}
        
        for round_num, day, home, away in schedule:
            home_games[home] += 1
            away_games[away] += 1
        
        # Проверяем баланс для каждой команды
        for club in self.clubs:
            self.assertEqual(home_games[club], 15, 
                           f"Команда {club} имеет {home_games[club]} домашних матчей вместо 15")
            self.assertEqual(away_games[club], 15, 
                           f"Команда {club} имеет {away_games[club]} выездных матчей вместо 15")

    def test_consecutive_matches(self):
        """Тест на последовательные домашние/выездные матчи"""
        schedule = generate_league_schedule(self.championship)
        
        # Создаем словарь матчей для каждой команды
        team_schedules = {club: [] for club in self.clubs}
        for round_num, day, home, away in sorted(schedule):
            team_schedules[home].append(('home', round_num))
            team_schedules[away].append(('away', round_num))
        
        # Проверяем каждую команду
        for club, matches in team_schedules.items():
            matches.sort(key=lambda x: x[1])  # Сортируем по номеру тура
            
            consecutive_home = 0
            consecutive_away = 0
            
            for match_type, _ in matches:
                if match_type == 'home':
                    consecutive_home += 1
                    consecutive_away = 0
                else:
                    consecutive_away += 1
                    consecutive_home = 0
                
                self.assertLess(consecutive_home, 3,
                              f"Команда {club} имеет более 2 домашних матчей подряд")
                self.assertLess(consecutive_away, 3,
                              f"Команда {club} имеет более 2 выездных матчей подряд")

    def test_all_matches_in_one_day(self):
        """Тест, что все матчи тура проходят в один день"""
        create_championship_matches(self.championship)
        
        matches = self.championship.championshipmatch_set.all()
        rounds = matches.values('round').distinct()
        
        for round_data in rounds:
            round_num = round_data['round']
            round_matches = matches.filter(round=round_num)
            
            # Собираем все даты матчей в этом туре
            match_dates = set()
            for match in round_matches:
                match_dates.add(match.match.date.date())
            
            # Проверяем, что все матчи в один день
            self.assertEqual(len(match_dates), 1,
                           f"Матчи тура {round_num} проходят в разные дни: {match_dates}")

    def test_february_schedule(self):
        """Тест для февральского расписания"""
        # Создаем февральский сезон
        february_season = Season.objects.create(
            number=2,
            start_date=datetime(2024, 2, 1).date(),
            end_date=datetime(2024, 2, 28).date(),
            is_active=False
        )
        
        february_championship = Championship.objects.create(
            season=february_season,
            league=self.league,
            status='pending',
            start_date=february_season.start_date,
            end_date=february_season.end_date
        )
        
        # Добавляем те же команды
        for club in self.clubs:
            ChampionshipTeam.objects.create(
                championship=february_championship,
                team=club
            )
        
        create_championship_matches(february_championship)
        self.assertTrue(validate_championship_schedule(february_championship))

        # Проверяем наличие двойных туров 15 февраля
        double_matchday_matches = february_championship.championshipmatch_set.filter(
            match__date__date=datetime(2024, 2, 15).date()
        )
        self.assertEqual(double_matchday_matches.count(), 16,  # 8 матчей * 2 тура
                        "Неверное количество матчей в двойной игровой день")

# --- ????? ????? C:\realfootballsim\tournaments\tests.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\timezone_middleware.py ---

from django.utils import timezone
import pytz

class TimezoneMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        tzname = request.session.get('django_timezone')
        if tzname:
            timezone.activate(pytz.timezone(tzname))
        else:
            timezone.deactivate()
        return self.get_response(request)

# --- ????? ????? C:\realfootballsim\tournaments\timezone_middleware.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\urls.py ---

from django.urls import path
from . import views

app_name = 'tournaments'

urlpatterns = [
    path('', views.ChampionshipListView.as_view(), name='championship_list'),
    path('championship/<int:pk>/', views.ChampionshipDetailView.as_view(), name='championship_detail'),
    path('championship/<int:pk>/calendar/', views.ChampionshipCalendarView.as_view(), name='championship_calendar'),
    path('seasons/', views.SeasonListView.as_view(), name='season_list'),
    path('leagues/', views.LeagueListView.as_view(), name='league_list'),
    path('set-timezone/', views.set_timezone, name='set_timezone'),
    path('api/matches/<int:pk>/', views.get_championship_matches, name='api_matches'),
    path('my-championship/', views.MyChampionshipView.as_view(), name='my_championship'),
]

# --- ????? ????? C:\realfootballsim\tournaments\urls.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\utils.py ---

from typing import List, Tuple, Dict
from datetime import datetime, timedelta
from django.utils import timezone
from django.db import models, transaction
import calendar

def check_consecutive_matches(schedule: List[Tuple], team, is_home: bool) -> int:
    """
    Проверяет количество последовательных домашних или гостевых матчей для команды.
    """
    max_consecutive = 0
    current_consecutive = 0

    for match in schedule:
        if is_home:
            is_match = match[2] == team  # домашняя команда
        else:
            is_match = match[3] == team  # гостевая команда

        if is_match:
            current_consecutive += 1
            max_consecutive = max(max_consecutive, current_consecutive)
        else:
            current_consecutive = 0

    return max_consecutive

def get_team_matches(schedule: List[Tuple], team) -> List[Tuple[int, bool]]:
    """
    Возвращает список матчей команды с информацией о домашних/гостевых играх.
    """
    team_matches = []
    for round_num, day, home, away in schedule:
        if home == team:
            team_matches.append((round_num, True))
        elif away == team:
            team_matches.append((round_num, False))
    return sorted(team_matches)

def validate_schedule_balance(schedule: List[Tuple], teams: List) -> Dict:
    """
    Проверяет баланс домашних и гостевых матчей для каждой команды.
    """
    balance = {team: {'home': 0, 'away': 0} for team in teams}

    for _, _, home, away in schedule:
        balance[home]['home'] += 1
        balance[away]['away'] += 1

    return balance

def generate_league_schedule(championship) -> List[Tuple]:
    """
    Генерирует сбалансированное расписание матчей по принципу кругового турнира.
    """
    from .models import Championship  # Импорт внутри функции
    
    teams = list(championship.teams.all())
    if len(teams) != 16:
        raise ValueError(f"Требуется ровно 16 команд, сейчас: {len(teams)}")
    
    n = len(teams)
    rounds = n - 1
    schedule = []
    
    # Создаем массив с номерами команд
    team_numbers = list(range(n))
    
    # Генерируем матрицу встреч
    matches = []
    for round_num in range(rounds):
        round_matches = []
        for i in range(n // 2):
            home = team_numbers[i]
            away = team_numbers[n - i - 1]
            # Чередуем домашние и выездные матчи
            if (i + round_num) % 2 == 0:
                round_matches.append((home, away))
            else:
                round_matches.append((away, home))
        matches.append(round_matches)
        # Ротация команд
        team_numbers = [team_numbers[0]] + team_numbers[-1:] + team_numbers[1:-1]
    
    # Создаем расписание для первого и второго кругов
    for half in range(2):
        for round_num in range(rounds):
            actual_round = round_num + 1 + half * rounds
            round_matches = matches[round_num]
            for match_num, (home_idx, away_idx) in enumerate(round_matches):
                if half == 1:
                    # Во втором круге меняем хозяев и гостей
                    home_idx, away_idx = away_idx, home_idx
                home_team = teams[home_idx]
                away_team = teams[away_idx]
                schedule.append((actual_round, match_num + 1, home_team, away_team))
    
    return schedule

def create_championship_matches(championship) -> None:
    """
    Создает матчи чемпионата на основе сгенерированного расписания.
    """
    from .models import ChampionshipMatch  # Импорт внутри функции
    from matches.models import Match  # Импорт внутри функции
    
    with transaction.atomic():
        ChampionshipMatch.objects.filter(championship=championship).delete()

        schedule = generate_league_schedule(championship)
        matches_by_round = {}
        
        # Группируем матчи по турам
        for round_num, day, home_team, away_team in schedule:
            if round_num not in matches_by_round:
                matches_by_round[round_num] = []
            matches_by_round[round_num].append((day, home_team, away_team))
            
        current_date = championship.start_date

        # Создаем матчи
        for round_num in sorted(matches_by_round.keys()):
            match_time = championship.match_time
            if championship.league.level == 2:
                match_time = (
                    datetime.combine(datetime.min, match_time) - 
                    timedelta(hours=2)
                ).time()

            match_datetime = timezone.make_aware(
                datetime.combine(current_date, match_time)
            )

            for day, home_team, away_team in matches_by_round[round_num]:
                match = Match.objects.create(
                    home_team=home_team,
                    away_team=away_team,
                    datetime=match_datetime,
                    status='scheduled'
                )

                ChampionshipMatch.objects.create(
                    championship=championship,
                    match=match,
                    round=round_num,
                    match_day=current_date.day
                )

            current_date += timedelta(days=1)

def validate_championship_schedule(championship) -> bool:
    """
    Проверяет корректность расписания чемпионата.
    """
    from .models import Championship  # Импорт внутри функции
    
    matches = championship.championshipmatch_set.select_related('match')
    teams = list(championship.teams.all())

    # Проверка количества матчей
    expected_matches = len(teams) * (len(teams) - 1)
    if matches.count() != expected_matches:
        return False

    # Проверка баланса матчей
    team_matches = {team: {'home': 0, 'away': 0} for team in teams}
    for match in matches:
        team_matches[match.match.home_team]['home'] += 1
        team_matches[match.match.away_team]['away'] += 1

    for team, stats in team_matches.items():
        if stats['home'] != (len(teams) - 1) or stats['away'] != (len(teams) - 1):
            return False

    # Проверка последовательности матчей
    for team in teams:
        team_schedule = list(matches.filter(
            models.Q(match__home_team=team) | models.Q(match__away_team=team)
        ).order_by('round'))

        home_streak = 0
        away_streak = 0
        max_home_streak = 0
        max_away_streak = 0

        for match in team_schedule:
            if match.match.home_team == team:
                home_streak += 1
                away_streak = 0
                max_home_streak = max(max_home_streak, home_streak)
            else:
                away_streak += 1
                home_streak = 0
                max_away_streak = max(max_away_streak, away_streak)

        if max_home_streak > 2 or max_away_streak > 2:
            return False

    return True

# --- ????? ????? C:\realfootballsim\tournaments\utils.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\views.py ---

from django.views.generic import ListView, DetailView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect
from django.contrib import messages
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
from django.urls import reverse
from django.conf import settings
import json
from django.utils import timezone
from django.http import JsonResponse
from django.db import models
from .models import Championship, Season, League

class ChampionshipListView(LoginRequiredMixin, ListView):
    model = Championship
    template_name = 'tournaments/championship_list.html'
    context_object_name = 'championships'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['active_seasons'] = Season.objects.filter(is_active=True)
        context['championships'] = Championship.objects.all().select_related(
            'league', 'season'
        ).order_by('league__level')
        return context

class ChampionshipDetailView(LoginRequiredMixin, DetailView):
    model = Championship
    template_name = 'tournaments/championship_detail.html'
    context_object_name = 'championship'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        context['standings'] = (
            self.object.championshipteam_set
            .annotate(
                goals_diff=models.F('goals_for') - models.F('goals_against')
            )
            .order_by('-points', '-goals_diff', '-goals_for')
        )
        
        matches = self.object.championshipmatch_set.all().select_related(
            'match', 
            'match__home_team', 
            'match__away_team'
        ).order_by('round', 'match__datetime')
        
        context['matches'] = matches
        
        calendar_events = []
        for match in matches:
            calendar_events.append({
                'id': match.id,
                'title': f"{match.match.home_team} vs {match.match.away_team}",
                'start': match.match.datetime.isoformat(),
                'status': match.match.status,
                'score': f"{match.match.home_score} - {match.match.away_score}" if match.match.status == 'finished' else None,
                'url': reverse('matches:match_detail', args=[match.match.id]),
                'className': f"match-{match.match.status}"
            })
        
        context['calendar_events'] = json.dumps(calendar_events)
        context['user_timezone'] = self.request.session.get('timezone', timezone.get_current_timezone_name())
        
        return context

class MyChampionshipView(LoginRequiredMixin, DetailView):
    model = Championship
    template_name = 'tournaments/my_championship.html'
    
    def dispatch(self, request, *args, **kwargs):
        if not hasattr(request.user, 'club'):
            messages.warning(request, "You need to create a club first.")
            return redirect('clubs:create_club')
        return super().dispatch(request, *args, **kwargs)
    
    def get_object(self):
        try:
            return Championship.objects.select_related(
                'league',
                'season'
            ).get(
                teams=self.request.user.club,
                season__is_active=True
            )
        except Championship.DoesNotExist:
            raise Http404("No championship found for your club")
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        championship = self.object
        user_club = self.request.user.club

        # Get standings
        context['standings'] = championship.championshipteam_set.select_related(
            'team'
        ).order_by(
            '-points', 
            '-goals_for'
        )

        # Get team matches for display
        context['team_matches'] = championship.championshipmatch_set.filter(
            models.Q(match__home_team=user_club) | 
            models.Q(match__away_team=user_club)
        ).select_related(
            'match', 
            'match__home_team', 
            'match__away_team'
        ).order_by('match__datetime')

        return context

class ChampionshipCalendarView(LoginRequiredMixin, DetailView):
    model = Championship
    template_name = 'tournaments/championship_calendar.html'
    context_object_name = 'championship'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        return context

class SeasonListView(LoginRequiredMixin, ListView):
    model = Season
    template_name = 'tournaments/season_list.html'
    context_object_name = 'seasons'

class LeagueListView(LoginRequiredMixin, ListView):
    model = League
    template_name = 'tournaments/league_list.html'
    context_object_name = 'leagues'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        countries = {}
        for league in self.get_queryset().order_by('country', 'level'):
            if league.country not in countries:
                countries[league.country] = []
            countries[league.country].append(league)
        context['countries'] = countries
        return context

def set_timezone(request):
    if request.method == 'POST':
        request.session['django_timezone'] = request.POST['timezone']
        return redirect(request.POST.get('next', '/'))
    else:
        return redirect('/')

def get_championship_matches(request, pk):
    championship = Championship.objects.get(pk=pk)
    matches = championship.championshipmatch_set.all().select_related(
        'match', 
        'match__home_team', 
        'match__away_team'
    )
    
    match_data = [{
        'id': match.id,
        'round': match.round,
        'date': match.match.datetime.isoformat(),
        'home_team': match.match.home_team.name,
        'away_team': match.match.away_team.name,
        'status': match.match.status,
        'score': f"{match.match.home_score}-{match.match.away_score}" if match.match.status == 'finished' else None
    } for match in matches]
    
    return JsonResponse({'matches': match_data})

# --- ????? ????? C:\realfootballsim\tournaments\views.py ---


# --- ?????? ????? C:\realfootballsim\tournaments\__init__.py ---


# --- ????? ????? C:\realfootballsim\tournaments\__init__.py ---


# --- ?????? ????? C:\realfootballsim\static\js\team_selection.js ---

document.addEventListener('DOMContentLoaded', function() {
    const pitch = document.getElementById('pitch');
    const playerList = document.getElementById('playerList');
    const clubId = document.getElementById('clubId').value;
    const resetButton = document.getElementById('resetButton');
    const saveStatus = document.getElementById('saveStatus');

    // Конфигурация позиций на поле
    const positions = [
        { top: '10%', left: '50%', type: 'goalkeeper', label: 'GK' },  // GK
        { top: '30%', left: '20%', type: 'defender', label: 'LB' },   // DEF
        { top: '30%', left: '40%', type: 'defender', label: 'CB' },
        { top: '30%', left: '60%', type: 'defender', label: 'CB' },
        { top: '30%', left: '80%', type: 'defender', label: 'RB' },
        { top: '60%', left: '30%', type: 'midfielder', label: 'LM' }, // MID
        { top: '60%', left: '50%', type: 'midfielder', label: 'CM' },
        { top: '60%', left: '70%', type: 'midfielder', label: 'RM' },
        { top: '80%', left: '30%', type: 'forward', label: 'LF' },    // FWD
        { top: '80%', left: '50%', type: 'forward', label: 'ST' },
        { top: '80%', left: '70%', type: 'forward', label: 'RF' }
    ];

    // Создание слотов для игроков на поле
    positions.forEach((pos, index) => {
        const slot = document.createElement('div');
        slot.className = 'player-slot';
        slot.style.top = pos.top;
        slot.style.left = pos.left;
        slot.dataset.position = index;
        slot.dataset.type = pos.type;

        // Добавляем подпись позиции
        const label = document.createElement('div');
        label.className = 'position-label';
        label.textContent = pos.label;
        slot.appendChild(label);

        pitch.appendChild(slot);
    });

    // Определение типа позиции игрока
    function getPlayerType(position) {
        if (position.includes('Goalkeeper')) return 'goalkeeper';
        if (position.includes('Back') || position.includes('Center Back')) return 'defender';
        if (position.includes('Midfielder')) return 'midfielder';
        if (position.includes('Forward') || position.includes('Striker')) return 'forward';
        return 'other';
    }

    // Создание элемента игрока
    function createPlayerElement(player) {
        const playerElement = document.createElement('div');
        const playerType = getPlayerType(player.position);
        playerElement.className = `player-item ${playerType}`;
        playerElement.dataset.playerId = player.id;
        playerElement.dataset.position = player.position;

        const nameElement = document.createElement('div');
        nameElement.className = 'player-name';
        nameElement.textContent = player.name;

        const positionElement = document.createElement('div');
        positionElement.className = 'player-position text-muted';
        positionElement.textContent = player.position;

        playerElement.appendChild(nameElement);
        playerElement.appendChild(positionElement);

        return playerElement;
    }

    // Показ сообщений
    function showMessage(text, type = 'success') {
        saveStatus.textContent = text;
        saveStatus.className = `alert alert-${type} mt-2`;
        setTimeout(() => {
            saveStatus.textContent = '';
            saveStatus.className = '';
        }, 3000);
    }

    // Сохранение состава
    function saveTeamLineup() {
        const lineup = {};
        document.querySelectorAll('.player-slot').forEach(slot => {
            const playerElem = slot.querySelector('.player-item');
            if (playerElem) {
                lineup[slot.dataset.position] = playerElem.dataset.playerId;
            }
        });

        showMessage('Сохранение...');
        fetch(`/clubs/detail/${clubId}/save-team-lineup/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(lineup)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showMessage('Состав успешно сохранен!');
            } else {
                showMessage('Ошибка при сохранении', 'danger');
            }
        })
        .catch(error => {
            showMessage('Ошибка сервера', 'danger');
            console.error('Error saving lineup:', error);
        });
    }

    // Загрузка текущего состава
    function loadTeamLineup() {
        fetch(`/clubs/detail/${clubId}/get-team-lineup/`)
            .then(response => response.json())
            .then(data => {
                if (data.lineup) {
                    Object.entries(data.lineup).forEach(([position, playerId]) => {
                        const slot = document.querySelector(`.player-slot[data-position="${position}"]`);
                        const player = document.querySelector(`.player-item[data-player-id="${playerId}"]`);
                        if (slot && player) {
                            slot.appendChild(player);
                        }
                    });
                }
            })
            .catch(error => {
                showMessage('Ошибка загрузки состава', 'danger');
                console.error('Error loading lineup:', error);
            });
    }

    // Сброс состава
    function resetLineup() {
        document.querySelectorAll('.player-slot .player-item').forEach(player => {
            playerList.appendChild(player);
        });
        saveTeamLineup();
        showMessage('Состав сброшен');
    }

    resetButton.addEventListener('click', resetLineup);

    // Инициализация Sortable
    function initializeSortable() {
        new Sortable(playerList, {
            group: 'shared',
            animation: 150,
            onEnd: saveTeamLineup
        });

        document.querySelectorAll('.player-slot').forEach(slot => {
            new Sortable(slot, {
                group: 'shared',
                animation: 150,
                onAdd: function(evt) {
                    const slotElement = evt.to;
                    const newPlayer = evt.item;
                    const slotType = slotElement.dataset.type;
                    const playerPosition = newPlayer.dataset.position;

                    // Проверка соответствия позиции
                    let isValid = false;
                    switch (slotType) {
                        case 'goalkeeper':
                            isValid = playerPosition.includes('Goalkeeper');
                            break;
                        case 'defender':
                            isValid = playerPosition.includes('Back') || playerPosition.includes('Center Back');
                            break;
                        case 'midfielder':
                            isValid = playerPosition.includes('Midfielder');
                            break;
                        case 'forward':
                            isValid = playerPosition.includes('Forward') || playerPosition.includes('Striker');
                            break;
                    }

                    if (!isValid) {
                        playerList.appendChild(newPlayer);
                        showMessage('Неверная позиция игрока!', 'danger');
                        return;
                    }
                    
                    // Удаляем всех существующих игроков из слота
                    slotElement.querySelectorAll('.player-item').forEach(player => {
                        if (player !== newPlayer) {
                            playerList.appendChild(player);
                        }
                    });
                    
                    // Перемещаем нового игрока в слот
                    slotElement.appendChild(newPlayer);
                    saveTeamLineup();
                }
            });
        });
    }

    // Загрузка игроков
    fetch(`/clubs/detail/${clubId}/get-players/`)
        .then(response => response.json())
        .then(players => {
            players.forEach(player => {
                const playerElement = createPlayerElement(player);
                playerList.appendChild(playerElement);
            });

            initializeSortable();
            loadTeamLineup();
        })
        .catch(error => {
            showMessage('Ошибка загрузки игроков', 'danger');
            console.error('Error loading players:', error);
        });

    // Получение CSRF токена
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
});

# --- ????? ????? C:\realfootballsim\static\js\team_selection.js ---

